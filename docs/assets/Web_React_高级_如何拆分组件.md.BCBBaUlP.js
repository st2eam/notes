import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.COET-Ywn.js";const o=JSON.parse('{"title":"[转]你是如何拆分组件的？","description":"","frontmatter":{},"headers":[],"relativePath":"Web/React/高级/如何拆分组件.md","filePath":"Web/React/高级/如何拆分组件.md"}'),l={name:"Web/React/高级/如何拆分组件.md"},t=n(`<h1 id="转-你是如何拆分组件的" tabindex="-1">[转]你是如何拆分组件的？ <a class="header-anchor" href="#转-你是如何拆分组件的" aria-label="Permalink to &quot;[转]你是如何拆分组件的？&quot;">​</a></h1><p><a href="https://juejin.cn/post/6844903493849858056?share_token=5cd81595-7c64-4daf-8eaa-6bc27d6d4771" target="_blank" rel="noreferrer">原文链接</a></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/9/2/9671c3f58ff429ed22c092fffa19dfe3~tplv-t2oaga2asx-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="img"></p><h1 id="你是如何拆分组件的" tabindex="-1">你是如何拆分组件的？ <a class="header-anchor" href="#你是如何拆分组件的" aria-label="Permalink to &quot;你是如何拆分组件的？&quot;">​</a></h1><p>React 组件会随着时间的推移而逐步增长。幸好我意识到了这一点，不然我的一些应用程序的组件将变得非常可怕。</p><p>但这实际上是一个问题吗？虽然创建许多只使用一次的小组件似乎有点奇怪……</p><p>在一个大型的 React 应用程序中，拥有大量的组件本身没有什么错。实际上，对于<strong>状态</strong>组件，我们当然是希望它们越小越好。</p><h2 id="臃肿组件的出现" tabindex="-1">臃肿组件的出现 <a class="header-anchor" href="#臃肿组件的出现" aria-label="Permalink to &quot;臃肿组件的出现&quot;">​</a></h2><p>关于状态它通常不会很好地分解。如果有多个动作作用于同一状态，那么它们都需要放在同一个组件中。状态可以被改变的方式越多，组件就越大。另外，如果一个组件有影响多个<a href="https://link.juejin.cn?target=http%3A%2F%2Fjamesknelson.com%2F5-types-react-application-state%2F" title="http://jamesknelson.com/5-types-react-application-state/" target="_blank" rel="noreferrer">状态类型</a>的动作，那么它将变得非常庞大，这是不可避免的。</p><p><strong>但即使大型组件不可避免，它们使用起来仍然是非常糟糕的</strong>。这就是为什么你会尽可能地拆分出更小的组件，遵循<a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSeparation_of_concerns" title="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noreferrer">关注点分离</a>的原则。</p><p>当然，说起来容易做起来难。</p><p>寻找关注点分离的方法是一门技术，更是一门艺术。但你可以遵循以下几种常见模式……</p><h2 id="_4-种类型的组件" tabindex="-1">4 种类型的组件 <a class="header-anchor" href="#_4-种类型的组件" aria-label="Permalink to &quot;4 种类型的组件&quot;">​</a></h2><p>根据我的经验，有四种类型的组件可以从较大的组件中拆分出来。</p><h3 id="视图组件" tabindex="-1">视图组件 <a class="header-anchor" href="#视图组件" aria-label="Permalink to &quot;视图组件&quot;">​</a></h3><p>有关视图组件（有些人称为展示组件）的更多信息，请参阅 Dan Abramov 的名著 —— <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40dan_abramov%2Fsmart-and-dumb-components-7ca2f9a7c7d0" title="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noreferrer">展示组件和容器组件</a>。</p><p>视图组件是最简单的组件类型。它们所做的就是<strong>显示信息，并通过回调发送用户输入</strong>。它们：</p><ul><li>将属性分发给子元素。</li><li>拥有将数据从子元素转发到父组件的回调。</li><li>通常是函数组件，但如果为了性能，它们需要绑定回调，则可能是类。</li><li>一般不使用生命周期方法，性能优化除外。</li><li><strong>不</strong>直接存储状态，除了以 UI 为中心的状态，例如动画状态。</li><li><strong>不</strong>使用 refs 或直接与 DOM 进行交互（因为 DOM 的改变意味着状态的改变）。</li><li><strong>不</strong>修改环境。它们不应该直接将动作发送给 redux 的 store 或者调用 API 等。</li><li><strong>不</strong>使用 React 上下文。</li></ul><p>你可以从较大的组件中拆分出展示组件的一些迹象：</p><ul><li>有 DOM 标记或者样式。</li><li>有像列表项这样重复的部分。</li><li>有“看起来”像一个盒子或者区域的内容。</li><li>JSX 的一部分仅依赖于单个对象作为输入数据。</li><li>有一个具有不同区域的大型展示组件。</li></ul><p>可以从较大的组件中拆分出展示组件的一些示例：</p><ul><li>为多个子元素执行布局的组件。</li><li>卡片和列表项可以从列表中拆分出来。</li><li>字段可以从表单中拆分出来（将所有的更新合并到一个 <code>onChange</code> 回调中）。</li><li>标记可以从控件中拆分出来。</li></ul><h3 id="控制组件" tabindex="-1">控制组件 <a class="header-anchor" href="#控制组件" aria-label="Permalink to &quot;控制组件&quot;">​</a></h3><p>控制组件指的是<strong>存储与部分输入相关的状态</strong>的组件，即跟踪用户已发起动作的状态，而这些状态还未通过 <code>onChange</code> 回调产生有效值。它们与展示组件相似，但是：</p><ul><li>可以存储状态（当与部分输入相关时）。</li><li>可以使用 refs 和与 DOM 进行交互。</li><li>可以使用生命周期方法。</li><li>通常没有任何样式，也没有 DOM 标记。</li></ul><p>你可以从较大的组件中拆分出控制组件的一些迹象：</p><ul><li>将部分输入存储在状态中。</li><li>通过 refs 与 DOM 进行交互。</li><li>某些部分看起来像原生控件 —— 按钮，表单域等。</li></ul><p>控制组件的一些示例：</p><ul><li>日期选择器</li><li>输入提示</li><li>开关</li></ul><p>你经常会发现你的很多控件具有相同的行为，但有不同的展现形式。在这种情况下，通过将展现形式拆分成视图组件，并作为 <code>theme</code> 或 <code>view</code> 属性传入是有意义的。</p><p>你可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Freact-dnd%2Freact-dnd" title="https://github.com/react-dnd/react-dnd" target="_blank" rel="noreferrer">react-dnd</a> 库中查看连接器函数的实际示例。</p><p>当从控件中拆分出展示组件时，你可能会发现通过 <code>props</code> 将单独的 <code>ref</code> 函数和回调传递给展示组件感觉有点不对。在这种情况下，它可能有助于传递<strong>连接器函数</strong>，这个函数将 refs 和回调克隆到传入的元素中。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyControl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 连接器函数使用 React.cloneElement 将事件处理程序</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 和 refs 添加到由展示组件创建的元素中。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  connectControl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cloneElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ref: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.receiveRef,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      onClick: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.handleClick,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 你可以通过属性将展示组件传递给控件，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 从而允许控件以任意标记和样式来作为主题。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.props.view, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      connectControl: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.connectControl,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  receiveRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ... */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 展示组件可以在 \`connectControl\` 中包裹一个元素，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以添加适当的回调和 \`ref\` 函数。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ControlView</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">connectControl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> connectControl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;some-class&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      control content goes here    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>你会发现控制组件通常会非常大。它们必须处理和状态密不可分的 DOM，这就使得控制组件的拆分特别有用；通过将 DOM 交互限制为控制组件，你可以将任何与 DOM 相关的杂项放在一个地方。</p><h3 id="控制器" tabindex="-1">控制器 <a class="header-anchor" href="#控制器" aria-label="Permalink to &quot;控制器&quot;">​</a></h3><p>一旦你将展示和控制代码拆分到独立的组件中后，大部分剩余的代码将是业务逻辑。如果有一件事我想你在阅读本文之后记住，那就是<strong>业务逻辑不需要放在 React 组件</strong>中。将业务逻辑用普通 JavaScript 函数和类来实现通常是有意义的。由于没有一个更好的名字，我将它称之为<strong>控制器</strong>。</p><p>所以只有三种类型的 <strong>React</strong> 组件。但仍然有四种类型的组件，因为不是每个组件都是一个 React 组件。</p><p>并不是每辆车都是丰田（但至少在东京大部分都是）。</p><p>控制器通常遵循类似的模式。它们：</p><ul><li>存储某个状态。</li><li>有改变那个状态的动作，并可能引起副作用。</li><li>可能有一些订阅状态变更的方法，而这些变更不是由动作直接造成的。</li><li>可以接受类似属性的配置，或者订阅某个全局控制器的状态。</li><li><strong>不</strong>依赖于任何 React API。</li><li><strong>不</strong>与 DOM 进行交互，也没有任何样式。</li></ul><p>你可以从你的组件中拆分出控制器的一些迹象：</p><ul><li>组件有很多与部分输入无关的状态。</li><li>状态用于存储从服务器接收到的信息。</li><li>引用全局状态，如拖放或导航的状态。</li></ul><p>一些控制器的示例：</p><ul><li>一个 Redux 或者 Flux 的 store。</li><li>一个带有 MobX 可观察的 JavaScript 类。</li><li>一个包含方法和实例变量的普通 JavaScript 类。</li><li>一个事件发射器。</li></ul><p>一些控制器是全局的；它们完全独立于你的 React 应用程序。Redux 的 stores 就是一个是全局控制器很好的例子。但<strong>并不是所有的控制器都需要是全局的</strong>，也并不是所有的状态都需要放在单独的控制器或者 store 中。</p><p>通过将表单和列表的控制器代码拆分为单独的类，你可以根据需要在容器组件中实例化这些类。</p><h3 id="容器组件" tabindex="-1">容器组件 <a class="header-anchor" href="#容器组件" aria-label="Permalink to &quot;容器组件&quot;">​</a></h3><p>容器组件是将控制器连接到展示组件和控制组件的粘合剂。它们比其他类型的组件更具有灵活性。但仍然倾向于遵循一些模式，它们：</p><ul><li>在组件状态中存储控制器实例。</li><li>通过展示组件和控制组件来渲染状态。</li><li>使用生命周期方法来订阅控制器状态的更新。</li><li><strong>不</strong>使用 DOM 标记或样式（可能出现的例外是一些无样式的 div）。</li><li>通常由像 Redux 的 <code>connect</code> 这样的高阶函数生成。</li><li>可以通过上下文访问全局控制器（例如 Redux 的 store）。</li></ul><p>虽然有时候你可以从其他容器中拆分出容器组件，但这很少见。相反，最好将精力集中在拆分控制器、展示组件和控制组件上，并将剩下的所有都变成你的容器组件。</p><p>一些容器组件的示例：</p><ul><li>一个 <code>App</code> 组件</li><li>由 Redux 的 <code>connect</code> 返回的组件。</li><li>由 MobX 的 <code>observer</code> 返回的组件。</li><li>react-router 的 <code>&lt;Link&gt;</code> 组件（因为它使用上下文并影响环境）。</li></ul><h2 id="组件文件" tabindex="-1">组件文件 <a class="header-anchor" href="#组件文件" aria-label="Permalink to &quot;组件文件&quot;">​</a></h2><p>你怎么称呼一个不是视图、控制、控制器或容器的组件？你只是把它叫做组件！很简单，不是吗？</p><p>一旦你拆分出一个组件，问题就变成了<strong>我把它放在哪里</strong>？老实说，答案很大程度上取决于个人喜好，但有一条规则我认为很重要：</p><p><strong>如果拆分出的组件只在一个父级中使用，那么它将与父级在同一个文件中</strong>。</p><p>这是为了尽可能容易地拆分组件。创建文件比较麻烦，并且会打断你的思路。如果你试着将每个组件放在不同的文件中，你很快就会问自己“我真的需要一个新组件吗？”因此，请将相关的组件放在同一个文件中。</p><p>当然，一旦你找到了重用该组件的地方，你可能希望将它移动到单独的文件中。这就使得把它放到哪个文件中去成为一个甜蜜的烦恼了。</p><h2 id="性能怎么样" tabindex="-1">性能怎么样？ <a class="header-anchor" href="#性能怎么样" aria-label="Permalink to &quot;性能怎么样？&quot;">​</a></h2><p>将一个庞大的组件拆分成多个控制器、展示组件和控制组件，增加了需要运行的代码总量。这可能会减慢一点点，但不会减慢很多。</p><h5 id="故事" tabindex="-1">故事 <a class="header-anchor" href="#故事" aria-label="Permalink to &quot;故事&quot;">​</a></h5><p>我遇到过唯一一次由于使用太多组件而引起性能问题 —— 我在<strong>每一帧</strong>上渲染 5000 个网格单元格，每个单元格都有多个嵌套组件。</p><p>关于 React 性能的是，即使你的应用程序有明显的延迟，问题肯定<strong>不是</strong>出于组件太多。</p><p><strong>所以你想使用多少组件都可以</strong>。</p><h2 id="如果没有拆分" tabindex="-1">如果没有拆分…… <a class="header-anchor" href="#如果没有拆分" aria-label="Permalink to &quot;如果没有拆分……&quot;">​</a></h2><p>我在本文中提到了很多规则，所以你可能会惊讶地听到我其实并不喜欢严格的规则。它们通常是错的，至少在某些情况下是这样。所以必须要明确的是:</p><p><strong>『可以』拆分并不意味着『必须』拆分</strong>。</p><p>假设你的目标是让你的代码更易于理解和维护，这仍然留下了一个问题：怎样才是易于理解？怎样才是易于维护？而答案往往取决于谁在问，这就是为什么重构是技术，更是艺术。</p><p>有一个具体的例子，考虑下这个组件的设计：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;!</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">DOCTYPE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;I&#39;m in a React app!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://unpkg.com/react@15.6.1/dist/react.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://unpkg.com/react-dom@15.6.1/dist/react-dom.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      // 这里写 JavaScript</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> List</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  renderItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item.id}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {item.name}      &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.props.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.renderItem)}      &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">List</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> items</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{[</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Item 1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },    { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Item 2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }  ]} /&gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>尽管将 <code>renderItem</code> 拆分成一个单独的组件是完全可能的，但这样做实际上会有什么好处呢？可能没有。实际上，在具有多个不同组件的文件中，使用 <code>renderItem</code> 方法可能会<strong>更容易</strong>理解。</p><p>请记住：四种类型的组件是当你觉得它们有意义的时候，你可以使用的一种模式。它们并不是硬性规定。如果你不确定某些内容是否需要拆分，那就不要拆分，因为即使某些组件比其他组件更臃肿，世界末日也不会到来。</p><blockquote><p>作者：undead25<br> 链接：<a href="https://juejin.cn/post/6844903493849858056" target="_blank" rel="noreferrer">[译] 你是如何拆分组件的？ - 掘金</a><br> 来源：稀土掘金<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>`,74),h=[t];function p(e,k,r,E,d,g){return a(),i("div",null,h)}const y=s(l,[["render",p]]);export{o as __pageData,y as default};
