import{_ as o,c as a,o as e,a4 as t}from"./chunks/framework.BtaI5osv.js";const H=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/React/Hooks/Hook.md","filePath":"Web/React/Hooks/Hook.md"}'),c={name:"Web/React/Hooks/Hook.md"},r=t('<h2 id="hook简介" tabindex="-1">Hook简介 <a class="header-anchor" href="#hook简介" aria-label="Permalink to &quot;Hook简介&quot;">​</a></h2><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p><p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React</p><h2 id="hook-是" tabindex="-1">Hook 是 <a class="header-anchor" href="#hook-是" aria-label="Permalink to &quot;Hook 是&quot;">​</a></h2><ul><li>完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook。</li><li>100% 向后兼容的。 Hook 不包含任何破坏性改动。</li></ul><p>没有计划从 React 中移除 class。</p><p>你可以在本页底部的章节读到更多关于 Hook 的渐进策略。</p><p>Hook 不会影响你对 React 概念的理解。 恰恰相反，Hook 为已知的 React 概念提供了更直接的 API：props， state，context，refs 以及生命周期。稍后我们将看到，Hook 还提供了一种更强大的方式来组合他们。</p><h2 id="为什么要用hooks" tabindex="-1">为什么要用Hooks？ <a class="header-anchor" href="#为什么要用hooks" aria-label="Permalink to &quot;为什么要用Hooks？&quot;">​</a></h2><h3 id="先说一下类组件的一些缺点" tabindex="-1">先说一下类组件的一些缺点 <a class="header-anchor" href="#先说一下类组件的一些缺点" aria-label="Permalink to &quot;先说一下类组件的一些缺点&quot;">​</a></h3><ul><li>缺点一：复杂且不容易理解的“this”</li><li>缺点二：组件数据状态逻辑不能重用、组件之间传值过程复杂</li><li>缺点三：复杂场景下代码难以组织在一起</li></ul><h3 id="hooks是如何解决上述类组件的缺点" tabindex="-1">Hooks是如何解决上述类组件的缺点？ <a class="header-anchor" href="#hooks是如何解决上述类组件的缺点" aria-label="Permalink to &quot;Hooks是如何解决上述类组件的缺点？&quot;">​</a></h3><h4 id="类组件缺点一-复杂且不容易理解的-this" tabindex="-1">类组件缺点一：复杂且不容易理解的“<code>this</code>” <a class="header-anchor" href="#类组件缺点一-复杂且不容易理解的-this" aria-label="Permalink to &quot;类组件缺点一：复杂且不容易理解的“`this`”&quot;">​</a></h4><p>Hooks解决方式：函数组件和普通JS函数非常相似，在普通JS函数中定义的变量、方法都可以不使用“<code>this</code>.”，而直接使用该变量或函数，因此你不再需要去关心“<code>this</code>”了。</p><h4 id="类组件缺点二-组件数据状态逻辑不能重用" tabindex="-1">类组件缺点二：组件数据状态逻辑不能重用 <a class="header-anchor" href="#类组件缺点二-组件数据状态逻辑不能重用" aria-label="Permalink to &quot;类组件缺点二：组件数据状态逻辑不能重用&quot;">​</a></h4><p>Hooks解决方式：<br> 通过<strong>自定义Hook</strong>，可以数据状态逻辑从组件中抽离出去，这样同一个Hook可以被多个组件使用，解决组件数据状态逻辑并不能重用的问题。</p><h4 id="类组件缺点三-组件之间传值过程复杂、缺点三-复杂场景下代码难以组织在一起" tabindex="-1">类组件缺点三：组件之间传值过程复杂、缺点三：复杂场景下代码难以组织在一起 <a class="header-anchor" href="#类组件缺点三-组件之间传值过程复杂、缺点三-复杂场景下代码难以组织在一起" aria-label="Permalink to &quot;类组件缺点三：组件之间传值过程复杂、缺点三：复杂场景下代码难以组织在一起&quot;">​</a></h4><p>Hooks解决方式：<br> 通过React内置的<code>useState()</code>函数，可以将不同数据分别从&quot;<code>this.state</code>&quot;中独立拆分出去。降低数据复杂度和可维护性，同时解决类组件缺点三中“内部state数据只能是整体，无法被拆分更细”的问题。</p><p>通过React内置的<code>useEffect()</code>函数，将<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUncount</code> 3个生命周期函数通过Hook(钩子)关联成1个处理函数，解决事件订阅分散在多个生命周期函数的问题。</p><p><strong>最为关键的是，hook还能实现一些类组件根本不能实现的功能，比如全局共享数据，代替Redux。</strong></p><h2 id="hook-规则" tabindex="-1">Hook 规则 <a class="header-anchor" href="#hook-规则" aria-label="Permalink to &quot;Hook 规则&quot;">​</a></h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noreferrer">linter</a> 插件来强制执行这些规则：</p><h3 id="只在最顶层使用-hook" tabindex="-1">只在最顶层使用 Hook <a class="header-anchor" href="#只在最顶层使用-hook" aria-label="Permalink to &quot;只在最顶层使用 Hook&quot;">​</a></h3><p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。 遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。(如果你对此感到好奇，我们在下面会有更深入的解释。)</p><h3 id="只在-react-函数中调用-hook" tabindex="-1">只在 React 函数中调用 Hook <a class="header-anchor" href="#只在-react-函数中调用-hook" aria-label="Permalink to &quot;只在 React 函数中调用 Hook&quot;">​</a></h3><p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p><ul><li>✅ 在 React 的函数组件中调用 Hook</li><li>✅ 在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p><h2 id="渐进策略" tabindex="-1">渐进策略 <a class="header-anchor" href="#渐进策略" aria-label="Permalink to &quot;渐进策略&quot;">​</a></h2><p><strong>总结：没有计划从 React 中移除 class。</strong></p><p>最重要的是，Hook 和现有代码可以同时工作，你可以渐进式地使用他们。</p>',31),s=[r];function h(i,l,k,n,d,p){return e(),a("div",null,s)}const b=o(c,[["render",h]]);export{H as __pageData,b as default};
