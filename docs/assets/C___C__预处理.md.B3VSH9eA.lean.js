import{_ as i,c as a,a2 as t,o as e}from"./chunks/framework.BW-ZVgUE.js";const o=JSON.parse('{"title":"define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：#define macro-name replacement-text","description":"","frontmatter":{},"headers":[],"relativePath":"C++/C++预处理.md","filePath":"C++/C++预处理.md"}'),n={name:"C++/C++预处理.md"};function l(h,s,p,d,k,r){return e(),a("div",null,s[0]||(s[0]=[t(`<h2 id="预处理器" tabindex="-1">预处理器 <a class="header-anchor" href="#预处理器" aria-label="Permalink to &quot;预处理器&quot;">​</a></h2><h3 id="宏定义" tabindex="-1">宏定义 <a class="header-anchor" href="#宏定义" aria-label="Permalink to &quot;宏定义&quot;">​</a></h3><blockquote><p>字符串的替换</p></blockquote><h1 id="define-预处理指令用于创建符号常量。该符号常量通常称为宏-指令的一般形式是-define-macro-name-replacement-text" tabindex="-1">define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：<code>#define macro-name replacement-text</code> <a class="header-anchor" href="#define-预处理指令用于创建符号常量。该符号常量通常称为宏-指令的一般形式是-define-macro-name-replacement-text" aria-label="Permalink to &quot;define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：\`\`\`#define macro-name replacement-text\`\`\`&quot;">​</a></h1><p>当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifndef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> π</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 先测试π是否被宏定义过</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#define π 3.1415926</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //如果没有则定义并执行程序段1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//程序段1   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#else</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       //如果已经定义则执行程序段2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//程序段2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span></code></pre></div><h3 id="参数宏" tabindex="-1">参数宏 <a class="header-anchor" href="#参数宏" aria-label="Permalink to &quot;参数宏&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)</span></span></code></pre></div><h3 id="和-运算符" tabindex="-1"># 和 ## 运算符 <a class="header-anchor" href="#和-运算符" aria-label="Permalink to &quot;# 和 ## 运算符&quot;">​</a></h3><blockquote><p>运算符会把replacement-text令牌转换为用引号引起来的字符串。</p></blockquote><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MYSTR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ) #x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">···</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MYSTR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HELLO C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endl;</span></span></code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：<code>HELLO C++</code></p><p>预处理器把<code>cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;</code></p><p>转换成了<code>cout &lt;&lt; &quot;HELLO C++&quot; &lt;&lt; endl;</code></p><blockquote><p>运算符用于连接两个令牌。</p></blockquote><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) a ## b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">···</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y);</span></span></code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：<code>100</code></p><p>预处理器把<code>cout &lt;&lt; concat(x, y);</code></p><p>转换成了<code>cout &lt;&lt; xy;</code></p><h3 id="c-中的预定义宏" tabindex="-1">C++ 中的预定义宏 <a class="header-anchor" href="#c-中的预定义宏" aria-label="Permalink to &quot;C++ 中的预定义宏&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;"><div style="width:80px;">宏</div></th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>__LINE__</code></td><td>代表当前源代码中的行号的整数常量。</td></tr><tr><td style="text-align:center;"><code>__FILE__</code></td><td>这会在程序编译时包含当前文件名。</td></tr><tr><td style="text-align:center;"><code>__DATE__</code></td><td>进行预处理的日期，格式为&quot;Mmm dd yyyy&quot;</td></tr><tr><td style="text-align:center;"></td><td><code>__TIME__</code></td></tr><tr><td style="text-align:center;"><code>__FUNCTION__</code></td><td>当前所在函数名</td></tr></tbody></table>`,21)]))}const E=i(n,[["render",l]]);export{o as __pageData,E as default};
