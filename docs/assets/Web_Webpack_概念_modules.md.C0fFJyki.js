import{_ as e,c as r,o as a,a4 as t}from"./chunks/framework.BtaI5osv.js";const b=JSON.parse('{"title":"模块（Modules）","description":"","frontmatter":{},"headers":[],"relativePath":"Web/Webpack/概念/modules.md","filePath":"Web/Webpack/概念/modules.md"}'),o={name:"Web/Webpack/概念/modules.md"},l=t('<h1 id="模块-modules" tabindex="-1">模块（Modules） <a class="header-anchor" href="#模块-modules" aria-label="Permalink to &quot;模块（Modules）&quot;">​</a></h1><p>在<a href="https://en.wikipedia.org/wiki/Modular_programming" target="_blank" rel="noreferrer">模块化编程</a>中，开发者将程序分解为功能离散的 chunk，并称之为 <strong>模块</strong>。</p><p>每个模块都拥有小于完整程序的体积，使得验证、调试及测试变得轻而易举。 精心编写的 <strong>模块</strong> 提供了可靠的抽象和封装界限，使得应用程序中每个模块都具备了条理清晰的设计和明确的目的。</p><p>Node.js 从一开始就支持模块化编程。 然而，web 的 <em>模块化</em> 正在缓慢支持中。 在 web 界存在多种支持 JavaScript 模块化的工具，这些工具各有优势和限制。 Webpack 从这些系统中汲取了经验和教训，并将 <em>模块</em> 的概念应用到项目的任何文件中。</p><h2 id="何为-webpack-模块" tabindex="-1">何为 webpack 模块 <a class="header-anchor" href="#何为-webpack-模块" aria-label="Permalink to &quot;何为 webpack 模块&quot;">​</a></h2><p>与 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noreferrer">Node.js 模块</a>相比，webpack <em>模块</em> 能以各种方式表达它们的依赖关系。下面是一些示例：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noreferrer">ES2015 <code>import</code></a> 语句</li><li><a href="http://www.commonjs.org/specs/modules/1.0/" target="_blank" rel="noreferrer">CommonJS</a> <code>require()</code> 语句</li><li><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noreferrer">AMD</a> <code>define</code> 和 <code>require</code> 语句</li><li>css/sass/less 文件中的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import" target="_blank" rel="noreferrer"><code>@import</code> 语句</a>。</li><li>stylesheet <code>url(...)</code> 或者 HTML <code>&lt;img src=...&gt;</code> 文件中的图片链接。</li></ul><h2 id="支持的模块类型" tabindex="-1">支持的模块类型 <a class="header-anchor" href="#支持的模块类型" aria-label="Permalink to &quot;支持的模块类型&quot;">​</a></h2><p>Webpack 天生支持如下模块类型：</p><ul><li><a href="https://webpack.docschina.org/guides/ecma-script-modules" target="_blank" rel="noreferrer">ECMAScript 模块</a></li><li>CommonJS 模块</li><li>AMD 模块</li><li><a href="https://webpack.docschina.org/guides/asset-modules" target="_blank" rel="noreferrer">Assets</a></li><li>WebAssembly 模块</li></ul><p>通过 <strong>loader</strong> 可以使 webpack 支持多种语言和预处理器语法编写的模块。<strong>loader</strong> 向 webpack 描述了如何处理非原生<em>模块</em>，并将相关<strong>依赖</strong>引入到你的 <strong>bundles</strong>中。 webpack 社区已经为各种流行的语言和预处理器创建了 <em>loader</em>，其中包括：</p><ul><li><a href="http://coffeescript.org/" target="_blank" rel="noreferrer">CoffeeScript</a></li><li><a href="https://www.typescriptlang.org/" target="_blank" rel="noreferrer">TypeScript</a></li><li><a href="https://babeljs.io/" target="_blank" rel="noreferrer">ESNext (Babel)</a></li><li><a href="http://sass-lang.com/" target="_blank" rel="noreferrer">Sass</a></li><li><a href="http://lesscss.org/" target="_blank" rel="noreferrer">Less</a></li><li><a href="http://stylus-lang.com/" target="_blank" rel="noreferrer">Stylus</a></li><li><a href="https://elm-lang.org/" target="_blank" rel="noreferrer">Elm</a></li></ul><p>当然还有更多！总得来说，webpack 提供了可定制，强大且丰富的 API，允许在 <strong>任何技术栈</strong> 中使用，同时支持在开发、测试和生产环境的工作流中做到 <strong>无侵入性</strong>。</p><p>关于 loader 的相关信息，请参考 <a href="https://webpack.docschina.org/loaders" target="_blank" rel="noreferrer"><strong>loader 列表</strong></a> 或 <a href="https://webpack.docschina.org/api/loaders" target="_blank" rel="noreferrer"><strong>自定义 loader</strong></a>。</p><h2 id="further-reading" tabindex="-1">Further Reading <a class="header-anchor" href="#further-reading" aria-label="Permalink to &quot;Further Reading&quot;">​</a></h2><ul><li><a href="https://auth0.com/blog/javascript-module-systems-showdown/" target="_blank" rel="noreferrer">JavaScript Module Systems Showdown</a></li></ul>',16),s=[l];function n(i,c,d,p,h,g){return a(),r("div",null,s)}const f=e(o,[["render",n]]);export{b as __pageData,f as default};
