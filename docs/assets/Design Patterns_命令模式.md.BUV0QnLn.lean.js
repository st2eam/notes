import{_ as l,E as t,c as p,J as n,w as h,a as i,m as s,a4 as k,o as e}from"./chunks/framework.BtaI5osv.js";const X=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Design Patterns/命令模式.md","filePath":"Design Patterns/命令模式.md"}'),d={name:"Design Patterns/命令模式.md"},r=s("h2",{id:"命令模式-command-pattern",tabindex:"-1"},[i("命令模式（Command Pattern） "),s("a",{class:"header-anchor",href:"#命令模式-command-pattern","aria-label":'Permalink to "命令模式（Command Pattern）"'},"​")],-1),E=s("p",null,"命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。",-1),g=s("img",{src:"https://refactoringguru.cn/images/patterns/content/command/command-zh.png?id=e5971678fc9f5e2f30599ff8424d4bd9"},null,-1),F=s("h3",{id:"问题",tabindex:"-1"},[i("问题 "),s("a",{class:"header-anchor",href:"#问题","aria-label":'Permalink to "问题"'},"​")],-1),y=s("p",null,[i("假如你正在开发一款新的文字编辑器， 当前的任务是创建一个包含多个按钮的工具栏， 并让每个按钮对应编辑器的不同操作。 你创建了一个非常简洁的"),s("code",null,"按钮"),i("类， 它不仅可用于生成工具栏上的按钮， 还可用于生成各种对话框的通用按钮。")],-1),c=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/problem1.png?id=84189315a0e8d91da262792979005ab4"},null,-1),o=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/problem2.png?id=f0e33da1842b3a3ee3b4857de0b6ec93"},null,-1),C=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/problem3-zh.png?id=6418d15863a142a7519ff7513841ee6d"},null,-1),B=s("p",null,[i("还有一个部分最难办。 复制/粘贴文字等操作可能会在多个地方被调用。 例如用户可以点击工具栏上小小的 “复制” 按钮， 或者通过上下文菜单复制一些内容， 又或者直接使用键盘上的 "),s("code",null,"Ctrl+C"),i("。")],-1),m=s("p",null,[i("我们的程序最初只有工具栏， 因此可以使用按钮子类来实现各种不同操作。 换句话来说， ​ 复制按钮"),s("code",null,"Copy­Button"),i("子类包含复制文字的代码是可行的。 在实现了上下文菜单、 快捷方式和其他功能后， 你要么需要将操作代码复制进许多个类中， 要么需要让菜单依赖于按钮， 而后者是更糟糕的选择。")],-1),u=s("h3",{id:"解决方案",tabindex:"-1"},[i("解决方案 "),s("a",{class:"header-anchor",href:"#解决方案","aria-label":'Permalink to "解决方案"'},"​")],-1),_=s("p",null,"优秀的软件设计通常会将关注点进行分离， 而这往往会导致软件的分层。 最常见的例子： 一层负责用户图像界面； 另一层负责业务逻辑。 GUI 层负责在屏幕上渲染美观的图形， 捕获所有输入并显示用户和程序工作的结果。 当需要完成一些重要内容时 （比如计算月球轨道或撰写年度报告）， GUI 层则会将工作委派给业务逻辑底层。",-1),A=s("p",null,"这在代码中看上去就像这样： 一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送请求给另一个对象。",-1),D=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/solution1-zh.png?id=ae19200346219d8dab71e6ce5169bdf0"},null,-1),f=s("p",null,"命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成命令类， 该类中仅包含一个用于触发请求的方法。",-1),b=s("p",null,"命令对象负责连接不同的 GUI 和业务逻辑对象。 此后， GUI 对象无需了解业务逻辑对象是否获得了请求， 也无需了解其对请求进行处理的方式。 GUI 对象触发命令即可， 命令对象会自行处理所有细节工作。",-1),x=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/solution2-zh.png?id=ba8af77475dbab21fb51081933efc4f5"},null,-1),I=s("p",null,"你可能会注意到遗漏的一块拼图——请求的参数。 GUI 对象可以给业务层对象提供一些参数。 但执行命令方法没有任何参数， 所以我们如何将请求的详情发送给接收者呢？ 答案是： 使用数据对命令进行预先配置， 或者让其能够自行获取数据。",-1),P=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/solution3-zh.png?id=3cc7b441711ae6188366a4b20c9877ef"},null,-1),v=s("p",null,"让我们回到文本编辑器。 应用命令模式后， 我们不再需要任何按钮子类来实现点击行为。 我们只需在 按钮Button基类中添加一个成员变量来存储对于命令对象的引用， 并在点击后执行该命令即可。",-1),U=s("p",null,"你需要为每个可能的操作实现一系列命令类， 并且根据按钮所需行为将命令和按钮连接起来。",-1),G=s("p",null,"其他菜单、 快捷方式或整个对话框等 GUI 元素都可以通过相同方式来实现。 当用户与 GUI 元素交互时， 与其连接的命令将会被执行。 现在你很可能已经猜到了， 与相同操作相关的元素将会被连接到相同的命令， 从而避免了重复代码。",-1),S=s("p",null,"最后， 命令成为了减少 GUI 和业务逻辑层之间耦合的中间层。 而这仅仅是命令模式所提供的一小部分好处！",-1),q=s("p",null,[i("原文链接："),s("a",{href:"https://refactoringguru.cn/design-patterns/command",target:"_blank",rel:"noreferrer"},"https://refactoringguru.cn/design-patterns/command")],-1),T=s("h3",{id:"命令模式结构",tabindex:"-1"},[i("命令模式结构 "),s("a",{class:"header-anchor",href:"#命令模式结构","aria-label":'Permalink to "命令模式结构"'},"​")],-1),V=s("img",{src:"https://refactoringguru.cn/images/patterns/diagrams/command/structure-indexed.png?id=d3212d2fa754a85afe1acb35775fee3e"},null,-1),w=k("",5);function N(z,K,$,H,J,R){const a=t("center");return e(),p("div",null,[r,E,n(a,null,{default:h(()=>[g]),_:1}),F,y,n(a,null,{default:h(()=>[c]),_:1}),n(a,null,{default:h(()=>[i("应用中的所有按钮都可以继承相同的类")]),_:1}),i(" 尽管所有按钮看上去都很相似， 但它们可以完成不同的操作 （打开、 保存、 打印和应用等）。 你会在哪里放置这些按钮的点击处理代码呢？ 最简单的解决方案是在使用按钮的每个地方都创建大量的子类。 这些子类中包含按钮点击后必须执行的代码。 "),n(a,null,{default:h(()=>[o]),_:1}),n(a,null,{default:h(()=>[i("大量的按钮子类。")]),_:1}),i(" 你很快就意识到这种方式有严重缺陷。 首先， 你创建了大量的子类， 当每次修改基类 按钮时， 你都有可能需要修改所有子类的代码。 简单来说， GUI 代码以一种拙劣的方式依赖于业务逻辑中的不稳定代码。 "),n(a,null,{default:h(()=>[C]),_:1}),i("多个类实现同一功能。 "),n(a,null,{default:h(()=>[i("多个类实现同一功能。")]),_:1}),B,m,u,_,A,n(a,null,{default:h(()=>[D]),_:1}),n(a,null,{default:h(()=>[i("GUI 层可以直接访问业务逻辑层。")]),_:1}),f,b,n(a,null,{default:h(()=>[x]),_:1}),n(a,null,{default:h(()=>[i("通过命令访问业务逻辑层。")]),_:1}),i(" 下一步是让所有命令实现相同的接口。 该接口通常只有一个没有任何参数的执行方法， 让你能在不和具体命令类耦合的情况下使用同一请求发送者执行不同命令。 此外还有额外的好处， 现在你能在运行时切换连接至发送者的命令对象， 以此改变发送者的行为。 "),I,n(a,null,{default:h(()=>[P]),_:1}),n(a,null,{default:h(()=>[i("GUI 对象将命令委派给命令对象。")]),_:1}),v,U,G,S,q,T,n(a,null,{default:h(()=>[V]),_:1}),w])}const Z=l(d,[["render",N]]);export{X as __pageData,Z as default};
