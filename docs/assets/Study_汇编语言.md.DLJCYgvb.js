import{_ as a,c as s,o as t,a4 as e}from"./chunks/framework.BtaI5osv.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Study/汇编语言.md","filePath":"Study/汇编语言.md"}'),n={name:"Study/汇编语言.md"},d=e(`<h3 id="框架" tabindex="-1">框架 <a class="header-anchor" href="#框架" aria-label="Permalink to &quot;框架&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.386</span></span>
<span class="line"><span>.MODEL FLAT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ExitProcess PROTO NEAR32 stdcall, dwExitCode:DWORD</span></span>
<span class="line"><span></span></span>
<span class="line"><span>INCLUDE io.h            ; header file for input/output</span></span>
<span class="line"><span></span></span>
<span class="line"><span>cr      EQU     0dh     ; carriage return character</span></span>
<span class="line"><span>Lf      EQU     0ah     ; line feed</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.STACK  4096            ; reserve 4096-byte stack</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.DATA                   ; reserve storage for data</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.CODE                           ; start of main program code</span></span>
<span class="line"><span>_start:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>PUBLIC _start                   ; make entry point public</span></span>
<span class="line"><span>END                             ; end of source code</span></span></code></pre></div><ul><li>.386 伪指令，它表示这是一个 32 位程序，能访问 32 位寄存器和地址。</li><li>.DATA 可以用于定义变量</li><li>.CODE 伪指令标识的程序区段包含了可执行的指令</li><li>.STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小</li><li>ExitProcess 函数的原型，它是一个标准的 Windows 服务。原型包含了函数名、PROTO 关键字、一个逗号，以及一个输入参数列表。ExitProcess 的输入参数名称为 dwExitCode</li><li>标号 main 它标记了程序开始执行的地址。</li></ul><h3 id="计算机中数的表示" tabindex="-1">计算机中数的表示 <a class="header-anchor" href="#计算机中数的表示" aria-label="Permalink to &quot;计算机中数的表示&quot;">​</a></h3><ul><li>二进制：b</li><li>八进制：o</li><li>十六进制：h -&gt; 注意和寄存器区别</li></ul><h4 id="进制间的转换" tabindex="-1">进制间的转换 <a class="header-anchor" href="#进制间的转换" aria-label="Permalink to &quot;进制间的转换&quot;">​</a></h4><p>有符号和无符号的区别</p><ul><li>最高位1为负数</li><li>最高位0为正数</li></ul><p><strong>补码间的转换</strong></p><p>正数：直接转换 负数：按位取反，末位加一</p><h3 id="ascii码" tabindex="-1">ASCII码 <a class="header-anchor" href="#ascii码" aria-label="Permalink to &quot;ASCII码&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>48-57： 0-9</span></span>
<span class="line"><span>65-90： A-Z</span></span>
<span class="line"><span>97-122：a-z</span></span></code></pre></div><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><table><thead><tr><th>类型</th><th>用法</th><th>大小</th></tr></thead><tbody><tr><td>BYTE</td><td>8 位无符号整数，B 代表字节</td><td>8位</td></tr><tr><td>WORD</td><td>16 位无符号整数</td><td>16位</td></tr><tr><td>DWORD</td><td>32 位无符号整数，D 代表双（字）</td><td>32位</td></tr></tbody></table><h3 id="寄存器" tabindex="-1">寄存器 <a class="header-anchor" href="#寄存器" aria-label="Permalink to &quot;寄存器&quot;">​</a></h3><ul><li>EAX：累加器</li><li>EBX：基地址寄存器</li><li>ECX：计数器</li><li>EDX：总是用来放整数除法产生的余数</li><li>ESI：源索引寄存器</li><li>EDI：目标索引寄存器</li><li>EBP：基址指针</li><li>ESP：堆栈指针</li></ul><h3 id="操作数的三种模式" tabindex="-1">操作数的三种模式 <a class="header-anchor" href="#操作数的三种模式" aria-label="Permalink to &quot;操作数的三种模式&quot;">​</a></h3><p>立即数——指令中含有数据： 常数、equ 寄存器——数据在寄存器中： 寄存器 存储器——数据在存储区域</p><h3 id="存储器操作数其中两种方式" tabindex="-1">存储器操作数其中两种方式 <a class="header-anchor" href="#存储器操作数其中两种方式" aria-label="Permalink to &quot;存储器操作数其中两种方式&quot;">​</a></h3><p>直接寻址——地址在指令中给出： 变量名、[常数] 寄存器间接寻址——数据的地址在寄存器中： [寄存器]</p><h3 id="标志位" tabindex="-1">标志位 <a class="header-anchor" href="#标志位" aria-label="Permalink to &quot;标志位&quot;">​</a></h3><ul><li>ZF——零标志位：结果为0，ZF=1，否则为0</li><li>SF——符号标志位：运算结果位负时，SF置为1</li><li>CF——进位标志位：最高位进位，CF=1，不进位为0</li><li>OF——溢出标志位：两操作数符号相同但结果与符号位相反，OF=1</li></ul><h2 id="指令" tabindex="-1">指令 <a class="header-anchor" href="#指令" aria-label="Permalink to &quot;指令&quot;">​</a></h2><p>在几乎所有的汇编语言指令中，左边的操作数是目标操作数，而右边的操作数是源操作数。</p><h3 id="复制数据指令" tabindex="-1">复制数据指令 <a class="header-anchor" href="#复制数据指令" aria-label="Permalink to &quot;复制数据指令&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>MOV 目的操作数,源操作数</span></span></code></pre></div><p>相当于</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>目的操作数 = 源操作数;</span></span></code></pre></div><h4 id="不合法指令" tabindex="-1">不合法指令 <a class="header-anchor" href="#不合法指令" aria-label="Permalink to &quot;不合法指令&quot;">​</a></h4><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>mov EAX, BL         × 两个寄存器位数不匹配</span></span>
<span class="line"><span>mov CS, AX          × 往代码段寄存器中传送数据</span></span>
<span class="line"><span>mov [ESI], [EBX]    × 源目的操作数都在内存</span></span>
<span class="line"><span>mov AH, 2589H       × 两操作数的位数不匹配</span></span>
<span class="line"><span>mov ES, DS          × 两操作数都是段寄存器</span></span>
<span class="line"><span>mov DS,3452H        × 立即数往段寄存器传送数据</span></span>
<span class="line"><span>mov 5, AH           × 目的操作数为立即数</span></span></code></pre></div><h3 id="定义变量" tabindex="-1">定义变量 <a class="header-anchor" href="#定义变量" aria-label="Permalink to &quot;定义变量&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.data                          ;此为数据区</span></span>
<span class="line"><span>sum DWORD 0                    ;定义名为sum的变量</span></span></code></pre></div><h3 id="输入输出" tabindex="-1">输入输出 <a class="header-anchor" href="#输入输出" aria-label="Permalink to &quot;输入输出&quot;">​</a></h3><p>IO.H中的宏</p><table><thead><tr><th><span style="width:200px;">宏</span></th><th>功能</th></tr></thead><tbody><tr><td><code>dtoa 目的操作数，源操作数 ;</code></td><td>把源操作数中的双字节数转换成一个11字节长的ASCII码，并存入目的操作数</td></tr><tr><td><code>atod 源操作数 ;</code></td><td>转换一个字符串为一双字长的2进制补码数</td></tr><tr><td><code>itoa 目的操作数，源操作数 ;</code></td><td>把源操作数（寄存器或存储器）中的单字节数转换成一个6字节长的ASCII码，并存入目的操作数</td></tr><tr><td><code>atoi 源操作数;</code></td><td>与atod类似，只是转换的结果存入AX寄存器，并且该数允许的范围是-32768到32767</td></tr><tr><td><code>output</code></td><td>输出源操作数中的字符串，该字符串必须以空字符串结束</td></tr><tr><td><code>input 目的操作数，长度</code></td><td>输入一个长度为length的字符串，并将该字符串存入目的操作数</td></tr></tbody></table><h3 id="算数指令" tabindex="-1">算数指令 <a class="header-anchor" href="#算数指令" aria-label="Permalink to &quot;算数指令&quot;">​</a></h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>add 目的操作数，源操作数</code></td><td>加</td></tr><tr><td><code>sub 目的操作数，源操作数</code></td><td>减</td></tr><tr><td><code>inc 目的操作数</code></td><td>自增</td></tr><tr><td><code>dec 目的操作数</code></td><td>自减</td></tr><tr><td><code>neg 目的操作数</code></td><td>取二进制数补码数</td></tr><tr><td><code>mul 源操作数</code></td><td>无符号乘法 乘积为EDX:EAX</td></tr><tr><td><code>imul 源操作数</code></td><td>累加器EAX作为另一个乘数</td></tr><tr><td><code>imul 寄存器 源操作数</code></td><td>乘积必须目的寄存器长度一致，那么OF、CF清零，否则置为1</td></tr><tr><td><code>imul 寄存器 源操作数 立即数</code></td><td>寄存器用来存放乘积，如果乘积和目的寄存器长度一致，那么OF、CF清零，否则置为1</td></tr><tr><td><code>idiv 源操作数</code></td><td>源操作数就是除数，被除数为AX（字节）或DX：AX（字）或EDX：EAX（双字） 商放入AL 余数放入AH</td></tr><tr><td><code>div 源操作数</code></td><td>无符号</td></tr></tbody></table><p>除法溢出：被除数的高半部大于等于除数</p><h3 id="数据大小转换" tabindex="-1">数据大小转换 <a class="header-anchor" href="#数据大小转换" aria-label="Permalink to &quot;数据大小转换&quot;">​</a></h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>cbw</code></td><td>字节转换为字；将AL寄存器中的二进制补码数扩展为AX中的字长</td></tr><tr><td><code>cwd</code></td><td>字转换为双字；将AX寄存器中的二进制数扩展为DX和AX中的双字</td></tr><tr><td><code>cdq</code></td><td>双字转换为四字；将EAX寄存器中的双字扩展为EDX和EAX中的四字</td></tr></tbody></table><h3 id="分支和循环" tabindex="-1">分支和循环 <a class="header-anchor" href="#分支和循环" aria-label="Permalink to &quot;分支和循环&quot;">​</a></h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>jmp StatementLabel</code></td><td>无条件转移</td></tr><tr><td><code>cmp 操作数1 操作数2</code></td><td>有条件转移</td></tr></tbody></table><h4 id="条件转移指令" tabindex="-1">条件转移指令 <a class="header-anchor" href="#条件转移指令" aria-label="Permalink to &quot;条件转移指令&quot;">​</a></h4><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>j-  statementLabel</span></span></code></pre></div><table><thead><tr><th>无符号</th><th>描述</th><th>有符号</th></tr></thead><tbody><tr><td><code>a</code></td><td>大于</td><td><code>g</code></td></tr><tr><td><code>b</code></td><td>小于</td><td><code>l</code></td></tr><tr><td><code>e</code></td><td>等于</td><td><code>e</code></td></tr><tr><td><code>n</code></td><td>否定</td><td><code>n</code></td></tr></tbody></table><h4 id="循环指令" tabindex="-1">循环指令 <a class="header-anchor" href="#循环指令" aria-label="Permalink to &quot;循环指令&quot;">​</a></h4><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>loop    statementLabel</span></span></code></pre></div><p>loop指令执行以下动作：</p><ul><li>ECX中的值减少</li><li>如果ECX中新的值是0，则执行下面的语句</li><li>如过ECX中新的值不是0，则执行转移指令到statementLabel</li></ul><h4 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h4><p>定义数组：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>变量名  DWORD   大小 DUP (?)</span></span></code></pre></div><p>取地址：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>lea 目的地址,源数据</span></span></code></pre></div><p>取当前项：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>[ebx]</span></span></code></pre></div><p>取出数组中下一项的地址：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>add ebx,4</span></span></code></pre></div><h3 id="过程" tabindex="-1">过程 <a class="header-anchor" href="#过程" aria-label="Permalink to &quot;过程&quot;">​</a></h3><h4 id="_80×86堆栈" tabindex="-1">80×86堆栈 <a class="header-anchor" href="#_80×86堆栈" aria-label="Permalink to &quot;80×86堆栈&quot;">​</a></h4><p>分配堆栈：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.STACK 4096</span></span></code></pre></div><p>内容出入堆栈</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>push    源操作数</span></span>
<span class="line"><span>pushw   字源操作数</span></span>
<span class="line"><span>pushd   双字源操作数</span></span>
<span class="line"><span>pop     目的操作数</span></span></code></pre></div><h4 id="过程体、调用和返回" tabindex="-1">过程体、调用和返回 <a class="header-anchor" href="#过程体、调用和返回" aria-label="Permalink to &quot;过程体、调用和返回&quot;">​</a></h4><p>过程体</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>子程序名 PROC near32</span></span>
<span class="line"><span>        push ebp    ;保存寄存器</span></span>
<span class="line"><span>        mov ebp esp ;建立堆栈</span></span>
<span class="line"><span>        ·</span></span>
<span class="line"><span>        ·</span></span>
<span class="line"><span>        ·</span></span>
<span class="line"><span>        pop ebp     ;恢复寄存器</span></span>
<span class="line"><span>        ret n   ;参数个数×4，释放参数</span></span>
<span class="line"><span>子程序名 ENDP</span></span></code></pre></div><p>调用：</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>call 目的过程</span></span></code></pre></div><h3 id="宏定义" tabindex="-1">宏定义 <a class="header-anchor" href="#宏定义" aria-label="Permalink to &quot;宏定义&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>name    MACRO   参数列表</span></span>
<span class="line"><span>        local   标号</span></span>
<span class="line"><span>        ·</span></span>
<span class="line"><span>        ·</span></span>
<span class="line"><span>        ·</span></span>
<span class="line"><span>        ENDM</span></span></code></pre></div><p>局部标号：local</p><p>在宏定义体的第一有效行，声明局部标号（多个就写同一行）</p><h3 id="串操作" tabindex="-1">串操作 <a class="header-anchor" href="#串操作" aria-label="Permalink to &quot;串操作&quot;">​</a></h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>cld</code></td><td>将DF清零，这样串指令使ESI和EDI的值递增，从左向右处理字符串</td></tr><tr><td><code>std</code></td><td>将DF置1，从右向左处理字符串</td></tr><tr><td><code>movs-</code></td><td>b:字节、w:字、d:双字；从源串传送到目的串:地址DS：ESI指向的源元素被复制到地址的ES：EDI</td></tr><tr><td><code>cmps-</code></td><td>b:字节、w:字、d:双字；为了判断两个串是否相同，那么repe前缀和cmps最好一起使用</td></tr><tr><td><code>scas-</code></td><td>b:字节、w:字、d:双字；用来在串中扫描某个特定的串元素是否在串中存在</td></tr><tr><td><code>stos-</code></td><td>b:字节、w:字、d:双字；将寄存器中的内容复制为目的串的某个元素了，不影响标志位</td></tr><tr><td><code>lods-</code></td><td>b:字节、w:字、d:双字；按照串元素的长度复制源串中的元素到AL，AX和EAX寄存器中</td></tr></tbody></table><h4 id="重复前缀" tabindex="-1">重复前缀 <a class="header-anchor" href="#重复前缀" aria-label="Permalink to &quot;重复前缀&quot;">​</a></h4><table><thead><tr><th>助记符</th><th>循环条件</th></tr></thead><tbody><tr><td><code>rep</code></td><td>ECX&gt;0</td></tr><tr><td><code>repz/repe</code></td><td>ECX&gt;0 &amp;&amp; ZF=1</td></tr><tr><td><code>repnz/repne</code></td><td>ECX&gt;0 &amp;&amp; ZF=0</td></tr></tbody></table><h3 id="位运算" tabindex="-1">位运算 <a class="header-anchor" href="#位运算" aria-label="Permalink to &quot;位运算&quot;">​</a></h3><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>and     目的操作数，源操作数</span></span>
<span class="line"><span>or      目的操作数，源操作数</span></span>
<span class="line"><span>xor     目的操作数，源操作数</span></span>
<span class="line"><span>nor     目的操作数，源操作数</span></span>
<span class="line"><span>test    目的操作数，源操作数    ；与操作不存结果，影响标志位</span></span></code></pre></div><h4 id="移位指令和循环移位指令" tabindex="-1">移位指令和循环移位指令 <a class="header-anchor" href="#移位指令和循环移位指令" aria-label="Permalink to &quot;移位指令和循环移位指令&quot;">​</a></h4><p><code>shl</code>和<code>shr</code>是逻辑移位</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>shl 目的地址,count    ;逻辑左，CF:为左边第一位，末尾补0</span></span>
<span class="line"><span>shr 目的地址,count    ;逻辑右，CF:为右边第一位,首位补0</span></span></code></pre></div><p><code>sal</code>和<code>sar</code>是算数移位</p><div class="language-assembly vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">assembly</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sal 目的地址,count    ;算数左，CF:为左边第一位，末尾补0</span></span>
<span class="line"><span>sar 目的地址,count    ;算数右，CF:为右边第一位,首位为1补1，为0补0</span></span></code></pre></div><p>一位移位中，结果符号位的值与源操作数相同则OF置为0，否则置1.</p>`,85),l=[d];function p(i,o,c,r,h,b){return t(),s("div",null,l)}const g=a(n,[["render",p]]);export{m as __pageData,g as default};
