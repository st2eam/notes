import{_ as e,c as a,o,a4 as c}from"./chunks/framework.B-C7vMfR.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Study/正则表达式.md","filePath":"Study/正则表达式.md"}'),d={name:"Study/正则表达式.md"},r=c('<h2 id="什么是正则表达式" tabindex="-1">什么是正则表达式？ <a class="header-anchor" href="#什么是正则表达式" aria-label="Permalink to &quot;什么是正则表达式？&quot;">​</a></h2><p>正则表达式是构成搜索模式（search pattern）的字符序列。</p><p>当您搜索文本中的数据时，您可使用搜索模式来描述您搜索的内容。</p><p>正则表达式可以是单字符，或者更复杂的模式。</p><p>正则表达式可用于执行所有类型的文本搜索和文本替换操作。</p><p><a href="https://regexr.com/" target="_blank" rel="noreferrer">RegExr: Learn, Build, &amp; Test RegEx</a></p><h3 id="限定符-quantifiers" tabindex="-1">限定符（Quantifiers） <a class="header-anchor" href="#限定符-quantifiers" aria-label="Permalink to &quot;限定符（Quantifiers）&quot;">​</a></h3><blockquote><p>（字符）表示括号内内容可以当作字符整体使用</p></blockquote><h4 id="表示前面-字符-需要出现0次或者1次" tabindex="-1">? ：表示前面(字符)需要出现0次或者1次 <a class="header-anchor" href="#表示前面-字符-需要出现0次或者1次" aria-label="Permalink to &quot;? ：表示前面(字符)需要出现0次或者1次&quot;">​</a></h4><p><code>used?</code>：use 和 used</p><h4 id="匹配前面-字符-0次或者多次" tabindex="-1">* ：匹配前面(字符)0次或者多次 <a class="header-anchor" href="#匹配前面-字符-0次或者多次" aria-label="Permalink to &quot;\\* ：匹配前面(字符)0次或者多次&quot;">​</a></h4><p><code>ab*c</code>：ac、abc、abbbc等</p><h4 id="匹配出现一次以上的-字符" tabindex="-1">+ ：匹配出现一次以上的(字符) <a class="header-anchor" href="#匹配出现一次以上的-字符" aria-label="Permalink to &quot;+ ：匹配出现一次以上的(字符)&quot;">​</a></h4><p><code>ab+c</code>：abc、abbbc等</p><h3 id="运算符" tabindex="-1">运算符 <a class="header-anchor" href="#运算符" aria-label="Permalink to &quot;运算符&quot;">​</a></h3><h4 id="运算符-1" tabindex="-1">{  }运算符 <a class="header-anchor" href="#运算符-1" aria-label="Permalink to &quot;{  }运算符&quot;">​</a></h4><p>{num}：匹配出现num次的字符</p><p>{num1,num2}：匹配出现的(字符)次数在num1和num2之间</p><p><code>num2</code>可以省略，<code>{num1,}</code>表示匹配出现<code>num1</code>次以上字符</p><p><code>/^(S|s){1}$/</code>：匹配单字符S或s</p><h4 id="或-运算符" tabindex="-1">或 ’<code>|</code> ‘运算符 <a class="header-anchor" href="#或-运算符" aria-label="Permalink to &quot;或 ’`|` ‘运算符&quot;">​</a></h4><p>就是平常理解的或运算符</p><p><code>(x|y)</code>--查找由 | 分隔的任何选项。</p><h3 id="字符类-character-classes" tabindex="-1">字符类（Character Classes） <a class="header-anchor" href="#字符类-character-classes" aria-label="Permalink to &quot;字符类（Character Classes）&quot;">​</a></h3><h4 id="运算符-2" tabindex="-1">[ ] 运算符 <a class="header-anchor" href="#运算符-2" aria-label="Permalink to &quot;[ ] 运算符&quot;">​</a></h4><p>方括号里的内容代表要求匹配的字符只能取自于[它们]</p><p><code>[abc]</code>--查找方括号之间的任何字符。 <code>[0-9]</code>--查找任何从 0 至 9 的数字。 <code>[a-zA-Z]</code>--查找所有的英文字符</p><h4 id="运算符-3" tabindex="-1">^ 运算符 <a class="header-anchor" href="#运算符-3" aria-label="Permalink to &quot;^ 运算符&quot;">​</a></h4><p>代表匹配除了<code>^</code>后面列出的[以外]的运算符</p><p><code>[^0-9]</code>表示所有的非数字字符（包括换行符）</p><h3 id="元字符-metacharacter" tabindex="-1">元字符（Metacharacter） <a class="header-anchor" href="#元字符-metacharacter" aria-label="Permalink to &quot;元字符（Metacharacter）&quot;">​</a></h3><p>小写：</p><ul><li><p><code>\\d</code>：数字字符 = <code>[0-9]</code></p></li><li><p><code>\\w</code>：单词字符（英文、数字以及下划线）</p></li><li><p><code>\\s</code>：空白符（包含Tab和换行符）</p></li></ul><p>大写：</p><ul><li><p><code>\\D</code>：非数字字符</p></li><li><p><code>\\W</code>：非单词字符</p></li><li><p><code>\\S</code>：非空白字符</p></li></ul><p>其他：</p><ul><li><p><code>\\b</code>：标注字符的边界（全字匹配）</p></li><li><p><code>.</code>：任意字符（不包含换行符）</p></li><li><p><code>^</code>：匹配行首</p></li><li><p><code>$</code>：匹配行尾</p></li><li><p><code>\\</code>：转义字符</p></li></ul><h3 id="正则表达式修饰符" tabindex="-1">正则表达式修饰符 <a class="header-anchor" href="#正则表达式修饰符" aria-label="Permalink to &quot;正则表达式修饰符&quot;">​</a></h3><ul><li><p><code>i</code>--执行对大小写不敏感的匹配。</p></li><li><p><code>g</code>--执行全局匹配。</p></li><li><p><code>m</code>--执行多行匹配。</p></li></ul><h3 id="贪婪-懒惰匹配" tabindex="-1">贪婪/懒惰匹配 <a class="header-anchor" href="#贪婪-懒惰匹配" aria-label="Permalink to &quot;贪婪/懒惰匹配&quot;">​</a></h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串</p><p><code>?</code>：贪婪匹配 → 懒惰匹配 例：</p><p><code>.+</code>：默认贪婪匹配&quot;任意字符&quot;</p><p><code>.+?</code>：懒惰匹配&quot;任意字符&quot;</p>',44),t=[r];function l(i,p,h,n,s,u){return o(),a("div",null,t)}const q=e(d,[["render",l]]);export{m as __pageData,q as default};
