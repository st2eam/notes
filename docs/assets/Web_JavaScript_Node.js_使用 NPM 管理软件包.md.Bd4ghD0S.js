import{_ as s,c as a,o as i,a4 as e}from"./chunks/framework.BtaI5osv.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/JavaScript/Node.js/使用 NPM 管理软件包.md","filePath":"Web/JavaScript/Node.js/使用 NPM 管理软件包.md"}'),n={name:"Web/JavaScript/Node.js/使用 NPM 管理软件包.md"},p=e(`<h2 id="使用-npm-管理软件包" tabindex="-1">使用 NPM 管理软件包 <a class="header-anchor" href="#使用-npm-管理软件包" aria-label="Permalink to &quot;使用 NPM 管理软件包&quot;">​</a></h2><p>npm（Node 包管理工具）是一个命令行工具，用于安装、创建和分享为 Node.js 编写的 JavaScript 代码包。在 npm 上有许多开放源码软件包，所以在项目启动之前，需要一些时间来探索，这样你就不会最后重新创建轮子来处理像日期或从 API 获取数据这样的事项。</p><h3 id="npm-有很多功能" tabindex="-1">npm 有很多功能 <a class="header-anchor" href="#npm-有很多功能" aria-label="Permalink to &quot;npm 有很多功能&quot;">​</a></h3><p><a href="https://yarnpkg.com/en/" target="_blank" rel="noreferrer">Yarn</a> 是 npm 的一个替代选择。</p><p>npm 的工作方式大致如下：</p><ul><li>架设一个中心化的代码仓库服务器（registry），用来存放共享的代码，官方的 npm 网站为 <a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">https://www.npmjs.com/</a>，在国内我们通常会使用阿里的 npm 镜像，下载速度会更快，切换方式如下npm config set registry <a href="https://registry.npmmirror.com" target="_blank" rel="noreferrer">https://registry.npmmirror.com</a></li><li>开源软件的作者将自己的代码封装成 npm 包（package），并且确定一个在 registry 中唯一的名字，如 react，然后将代码 publish 到 registry</li><li>其他开发者想要使用 react 这个包，在自己的项目中运行 npm i react ，npm 就会自动帮他们下载代码。</li><li>下载完成的代码会出现在项目根目录的 node_modules 目录</li><li>包也可以依赖 npm 上面其他的包，npm 在安装的时候会自动解析、安装这些依赖</li></ul><h3 id="安装所有依赖" tabindex="-1">安装所有依赖 <a class="header-anchor" href="#安装所有依赖" aria-label="Permalink to &quot;安装所有依赖&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span></span></code></pre></div><p>它会在 node_modules 文件夹（如果尚不存在则会创建）中安装项目所需的所有东西。</p><p>安装单个软件包</p><p>也可以通过运行以下命令安装特定的软件包：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">package-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>通常会在此命令中看到更多标志：</p><ul><li><code>--save</code>安装并添加条目到 package.json 文件的 dependencies。</li><li><code>--save-dev</code> 安装并添加条目到 package.json 文件的 devDependencies。</li></ul><p>区别主要是，devDependencies 通常是开发的工具（例如测试的库），而 dependencies 则是与生产环境中的应用程序相关。</p><h3 id="更新软件包" tabindex="-1">更新软件包 <a class="header-anchor" href="#更新软件包" aria-label="Permalink to &quot;更新软件包&quot;">​</a></h3><p>通过运行以下命令，更新也变得很容易：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> update</span></span></code></pre></div><p>npm 会检查所有软件包是否有满足版本限制的更新版本,当然也可以指定单个软件包进行更新。</p><h3 id="删除依赖" tabindex="-1">删除依赖 <a class="header-anchor" href="#删除依赖" aria-label="Permalink to &quot;删除依赖&quot;">​</a></h3><p>如果我们想要删除一个已安装的依赖，如 react，只需要在 package.json 所在的目录执行命令</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> remove</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vue</span></span></code></pre></div><p>如果要删除一个全局安装的模块，需要再加上 -g 的参数，如</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> remove</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> typescript</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span></span></code></pre></div><h3 id="运行任务" tabindex="-1">运行任务 <a class="header-anchor" href="#运行任务" aria-label="Permalink to &quot;运行任务&quot;">​</a></h3><p>package.json 文件支持一种用于指定命令行任务（可通过使用以下方式运行）的格式：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">task-nam</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div><p>使用此特性运行 Webpack 是很常见的：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;watch&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;webpack --watch --progress --colors --config webpack.conf.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;dev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;webpack --progress --colors --config webpack.conf.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;prod&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;NODE_ENV=production webpack -p --config webpack.conf.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>因此可以运行如下，而不是输入那些容易忘记或输入错误的长命令：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> watch</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prod</span></span></code></pre></div><h3 id="如何使用-package-json" tabindex="-1">如何使用 package.json <a class="header-anchor" href="#如何使用-package-json" aria-label="Permalink to &quot;如何使用 package.json&quot;">​</a></h3><blockquote><p>——所有 Node.js 项目或 npm 包的核心</p></blockquote><p><code>package.json</code> 文件是所有 Node.js 项目和 npm 包的枢纽， 和 HTML 文档中的 <head> 区域用来描述网页的配置信息（元数据）一样，它存储项目的相关信息。 它由单个 JSON 对象组成，并以键值对的形式存储项目信息， 且至少包含两个必填字段：“name”和“version”——但是最好提供有关项目的其他信息，这将对用户或者维护者有所帮助。</head></p><p><a href="http://nodejs.cn/learn/the-package-json-guide" target="_blank" rel="noreferrer">package.json</a> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。</p><p>这里有很多东西：</p><ul><li>version 表明了当前的版本。</li><li>name 设置了应用程序/软件包的名称。</li><li>description 是应用程序/软件包的简短描述。</li><li>main 设置了应用程序的入口点。</li><li>private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。</li><li>scripts 定义了一组可以运行的 node 脚本。</li><li>dependencies 设置了作为依赖安装的 npm 软件包的列表。</li><li>devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。</li><li>engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li><li>browserslist 用于告知要支持哪些浏览器（及其版本）。</li></ul><p>以上所有的这些属性都可被 npm 或其他工具使用。</p><h4 id="给-package-json-添加描述" tabindex="-1">给 package.json 添加描述 <a class="header-anchor" href="#给-package-json-添加描述" aria-label="Permalink to &quot;给 package.json 添加描述&quot;">​</a></h4><p>无论项目计划是什么，都建议使用描述。 类似这样：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;A project that does something awesome&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre></div><h4 id="给-package-json-添加关键词" tabindex="-1">给 package.json 添加关键词 <a class="header-anchor" href="#给-package-json-添加关键词" aria-label="Permalink to &quot;给 package.json 添加关键词&quot;">​</a></h4><p>在 <code>keywords</code> 字段中可以使用相关的关键字描述项目。 下面是一个示例：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;descriptive&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;related&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;words&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ],</span></span></code></pre></div><p>正如你所见的，这个字段的结构是一个由双引号字符串组成的数组。</p><h4 id="给-package-json-添加许可证" tabindex="-1">给 package.json 添加许可证 <a class="header-anchor" href="#给-package-json-添加许可证" aria-label="Permalink to &quot;给 package.json 添加许可证&quot;">​</a></h4><p><code>license</code> 字段将告知用户允许他们拿这个项目干什么。</p><p>开源项目常见的协议有 MIT 和 BSD 等。 许可证信息并不是必须的。 大多数国家的版权法会默认让你拥有自己创作的作品的所有权。 但是，明确说明用户可以做什么和不能做什么会是一个很好的做法。 这里有一个 license 字段的例子：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;license&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MIT&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre></div><h4 id="给-package-json-添加版本号" tabindex="-1">给 package.json 添加版本号 <a class="header-anchor" href="#给-package-json-添加版本号" aria-label="Permalink to &quot;给 package.json 添加版本号&quot;">​</a></h4><p><code>version</code> 是 package.json 文件中必填字段之一， 这个字段描述了当前项目的版本， 下面是一个示例：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.2.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre></div><h4 id="使用-npm-的外部包扩展项目" tabindex="-1">使用 npm 的外部包扩展项目 <a class="header-anchor" href="#使用-npm-的外部包扩展项目" aria-label="Permalink to &quot;使用 npm 的外部包扩展项目&quot;">​</a></h4><p>强大的依赖管理特性是使用包管理器的最大原因之一。 每当在新的计算机上开始一个项目时，无需手动，npm 会自动安装所有的依赖项。 但是 npm 如何准确地知道项目需要哪些依赖呢？ 来看看 package.json 文件中 <code>dependencies</code> 这一部分。</p><p>在这部分，你的项目需要按照下面这种格式来存储依赖包：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;package-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;express&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;4.14.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在 package.json 文件的依赖项中，npm 包的 <code>Versions</code> 遵循语义化版本（SemVer，Semantic Versioning），它是一种旨在使管理依赖项更加容易的软件版本控制的行业标准。 在 npm 上发布的库、框架或其它工具都应该使用语义化版本，以便让用户清晰地知道如果项目升级将带来哪些改变。</p><p>在使用外部依赖项（大多数情况都是这样）进行软件开发时，了解语义化版本会很有用。 这些数字保存着项目的偶然发生的破坏性改变，不会让人对项目昨天还正常，今天却无法运行而百思不解。 根据官网，这是语义化版本的工作方式：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;package&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MAJOR.MINOR.PATCH&quot;</span></span></code></pre></div><p>当做了不兼容的 API 修改，应该增加主版本号（MAJOR）； 当新增了向下兼容的新功能时，应该增加次版本号（MINOR）； 当修复了向下兼容的 bug 时，应该增加修订号（PATCH）。 这意味着修订号是用来修复错误的，次版本号则是添加了新功能，但它们都没有破坏之前的功能。 主版本号（MAJOR）是添加了不兼容早期版本的更改。</p><h4 id="用波浪号维持依赖项的最新修订号" tabindex="-1">用波浪号维持依赖项的最新修订号 <a class="header-anchor" href="#用波浪号维持依赖项的最新修订号" aria-label="Permalink to &quot;用波浪号维持依赖项的最新修订号&quot;">​</a></h4><p>如果想让项目各个部分保持相互兼容，锁定依赖包版本是一个行之有效的办法。 但是大多数情况下，我们并不希望错过依赖项的问题修复，因为它们通常包含重要的安全补丁，而且它们理论上也会兼容我们既有的代码。</p><p>可以在依赖项的版本号前加一个波浪号（<code>~</code>），以让 npm 依赖项更新到最新的修订版。 这里有一个允许升级到任何 1.3.x 的例子：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;package&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;~1.3.9&quot;</span></span></code></pre></div><h4 id="用-来使用依赖项的最新次要版本" tabindex="-1">用（^）来使用依赖项的最新次要版本 <a class="header-anchor" href="#用-来使用依赖项的最新次要版本" aria-label="Permalink to &quot;用（^）来使用依赖项的最新次要版本&quot;">​</a></h4><p>和用波浪号来安装最新的修订版依赖一样，脱字符（<code>^</code>）也允许 npm 来安装功能更新。 它们的不同之处在于：脱字符允许次版本和修订版更新。</p><p>现在项目中的 moment 依赖包的版本应该是“~2.10.2”，这意味着 npm 可以安装最新的 2.10.x 版的 moment， 如果使用脱字符（^）来替换版本号的前缀，那么 npm 可以将 moment 升级安装到任何 2.x.x 的版本。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;package&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.3.8&quot;</span></span></code></pre></div><p>这会将依赖包更新到任意的 1.x.x 版本。</p>`,69),t=[p];function l(h,o,k,d,r,c){return i(),a("div",null,t)}const E=s(n,[["render",l]]);export{u as __pageData,E as default};
