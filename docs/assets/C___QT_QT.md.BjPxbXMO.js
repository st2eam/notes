import{_ as a,c as n,o as e,a4 as s}from"./chunks/framework.COET-Ywn.js";const Q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"C++/QT/QT.md","filePath":"C++/QT/QT.md"}'),l={name:"C++/QT/QT.md"},t=s(`<h2 id="pro文件说明" tabindex="-1">pro文件说明 <a class="header-anchor" href="#pro文件说明" aria-label="Permalink to &quot;pro文件说明&quot;">​</a></h2><blockquote><p>QT += core gui<br> QT：指定使用类的模块</p></blockquote><blockquote><p>greaterThan(QT_MAJOR_VERSION,4):QT += widgets</p></blockquote><blockquote><p>TARGET = HelloQt<br> TARGET: 目标文名件</p></blockquote><blockquote><p>TEMPLATE = app<br> TEMPLATE: 编译方法</p></blockquote><blockquote><p>SOURCES += main.cpp\\widget.cpp<br> SOURCES: 源文件</p></blockquote><blockquote><p>HEADERS += widget.h<br> HEADERS: 头文件</p></blockquote><blockquote><p>FORMS += widget.ui<br> FORMS: 指定ui文件</p></blockquote><h2 id="qt开发框架" tabindex="-1">QT开发框架 <a class="header-anchor" href="#qt开发框架" aria-label="Permalink to &quot;QT开发框架&quot;">​</a></h2><p><img src="https://note.youdao.com/yws/res/6520/D1484380935446F4916F074C562DB90C" alt="image"></p><h2 id="qapplication类" tabindex="-1">QApplication类 <a class="header-anchor" href="#qapplication类" aria-label="Permalink to &quot;QApplication类&quot;">​</a></h2><ul><li>QApplication类管理GUI程序的控制流和主要设置，是基于QWidget的，为此特化了QGuiApplication的一些功能，处理QWidget特有的初始化和结束收尾工作.</li><li>对于使用了Qt的任何GUI程序来说，不管何时何地有多少个Window，但只有一个QApplication对象，如果不是基于QWidget的程序，相应的则使用QGuiApplication，后者不依赖于Widget特有的库。</li><li>有些程序是不使用GUI的，通过命令行参数执行不同的任务而不用手动设置，这时使用QCoreApplication就够了，避免初始化不必要的GUI资源。</li></ul><h4 id="qapplication的主要职责-可以参考qassitant帮助" tabindex="-1">QApplication的主要职责 (可以参考QAssitant帮助) <a class="header-anchor" href="#qapplication的主要职责-可以参考qassitant帮助" aria-label="Permalink to &quot;QApplication的主要职责 (可以参考QAssitant帮助)&quot;">​</a></h4><ol><li>使用用户的桌面设置进行初始化，这些设置如palette()、font()、doubleClickInterval()，然后跟踪这些属性的变化，如用户通过某种配置面板修改了全局桌面设置。</li><li>处理事件，从窗口系统接收事件并派发到相应的Widget，使用sendEvent()和postEvent()函数可以派发事件。</li><li>处理命令行参数，设置内部状态。</li><li>定义GUI外观，外观由QStyle对象包装，运行时通过setStyle()函数进行设置。</li><li>设置颜色分配规则，对应的函数为setColorSpec()。</li><li>本地化字符串，函数为translate()。</li><li>提供了一些有用的对象，如desktop()、clipboard()函数。</li><li>知道Widget及Window，相应的函数为widgetAt()、topLevelWidgets()、closeAllWindows()。</li><li>管理鼠标光标，函数为setOverrideCursor()。</li></ol><p>从上面可以看出，QApplication作了许多初始化工作，因此在任何其它的UI对象创建之前必须先创建QApplication对象，而且还可以通过命令行参数设置一些内部状态。</p><h4 id="qapplication总结" tabindex="-1">QApplication总结 <a class="header-anchor" href="#qapplication总结" aria-label="Permalink to &quot;QApplication总结&quot;">​</a></h4><p><strong>Qt消息循环</strong>，就是从一个队列中不断取出消息，并响应消息的过程。窗体的鼠标、键盘、输入法、绘制，各种消息，都来自于Qt的消息循环。以Windows操作系统为例，Qt接管Windows原生窗口消息，并翻译成Qt的消息，派发给程序下的各个子对象、子QWidget等，通过接管层，可以很好屏蔽不同平台之间的差异性，开发人员不需要关心Windows或者X11的消息的差异性，只需要搞清楚各个QEvent之间是什么含义。</p><p>最开始的Qt消息循环开始于QCoreApplication::exec()。用户创建出一个QCoreApplication，或者说更多情况下是QApplication，执行QCoreApplication::exec()，一个应用程序便开始了。QCoreApplication会不断从操作系统获取消息，并且分发给QObject。</p><p>如果没有消息循环，那么Qt的信号和槽无法完全使用，有些函数也无法正确执行。举个例子，通过QueuedConnection连接的信号，其实是将一个事件压入了消息循环，如果没有QCoreApplication::exec()，那么这个消息循环将永远无法派发到指定的对象。</p><h2 id="qobject" tabindex="-1">QObject <a class="header-anchor" href="#qobject" aria-label="Permalink to &quot;QObject&quot;">​</a></h2><p>QObject是所有Qt对象的基类，是Qt Object Model（对象模型）的核心。<br> 作用:</p><ul><li>父子对象树机制-内存管理机制</li><li>信号和槽机制</li><li>定时器与事件过滤</li><li>翻译</li><li>其他，如线程等。</li></ul><h2 id="qt内存管理" tabindex="-1">QT内存管理 <a class="header-anchor" href="#qt内存管理" aria-label="Permalink to &quot;QT内存管理&quot;">​</a></h2><p>在C++中内存分为5个区，分别是堆、栈、自由存储区、全局/静态存储区和常量存储区<br><strong>堆(heap)</strong>：分配方式类似于链表；一般由程序员分配和释放，若程序员不释放，OS可能回收。分配方法：malloc、new ；释放方法：free delete</p><p><strong>栈(heap)</strong>：编译器自动分配释放，存放函数参数值、局部变量的值。操作方式类似于：数据结构的栈。 进程的每个线程都有私有的栈</p><p><strong>全局/静态存储区（static）</strong>：全局变量和静态变量的存储位置，由系统分配和释放。初始化的存放于.data，未初始化的在.bss。 默认初始化为0</p><p><strong>常量区（文字常量区）</strong>：存放常量字符串，存放于.rodata， 程序结束后有系统释放。 程序代码区：存放函数体的二进制代码(.text)</p><ul><li>堆栈 存放本地变量 即局部变量。在堆栈中，程序通过堆栈的基址和偏移量来访问本地变量</li></ul><hr><ul><li>使用 new 和 delete时，内存在堆中分配。堆内存空间必须通过delete完全释放。只要不delete，分配在堆上的对象就可以一直存活下去</li><li>栈是系统自动分配管理的，局部变量就是来自于栈区，只要超过了作用域的栈区数据就会被自动回收</li></ul><hr><ul><li>所有从QObject继承出来的子对象的内存管理都转移给了父对象 <ul><li>使用new在堆上分配内存</li><li>子对象可自动被父对象删除内存</li><li>手动删除不会引起二次删除，子对象删除时会通知父对象</li></ul></li><li>没有父对象的对象需要手工删除 <ul><li>没有父对象的对象一般分配在栈区，这样可以有效避免内存泄漏</li></ul></li><li>QT没有自动回收站的机制，需要关注父子关系及其功能</li></ul><hr><ul><li>在构造对象的时候指定父对象<br><code>QObject(QObject *parent = 0)</code></li><li>QObject可以修改它所属的父对象<br><code>void QObject::setParent(QObject * parent)</code></li><li>得到子对象<br><code>QObjectList &amp; QObject::children()</code></li><li>得到父对象<br><code>QObject *QObject::parent()</code></li><li>手工删除有父对象的从QObject继承的子对象<br><code>void QObject::deleteLater()</code></li></ul><hr><ul><li>在Qt中，最基础和核心的类是：QObject，QObject内部有一个list，会保存children，还有一个指针保存parent，当自己析构时，会自己从parent列表中删除并且析构所有的children</li></ul><hr><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><ul><li>所有从QObject继承出来的子对象的内存管理都转移给了父对象 <ul><li>使用new在堆上分配内存</li><li>子对象可自动被父对象删除内存</li><li>手动删除不会引起二次删除，子对象删除时会通知父对象</li></ul></li><li>没有父对象的对象需要手工删除 <ul><li>没有父对象的对象一般分配在栈区，这样可以有效避免内存泄漏</li></ul></li><li>当一个QOBJECT正在接受事件队列时如果中途被你DELETE掉了，就是出现问题了，所以QT中建议大家不要直接DELETE掉一个 QOBJECT，如果一定要这样做，要使用QOBJECT的deleteLater()函数，它会让所有事件都发送完一切处理好后马上清除这片内存，而且就算调用多次的deletelater也不会有问题。</li><li>QT不建议在一个QOBJECT 的父亲的范围之外持有对这个QOBJECT的指针，因为如果这样外面的指针很可能不会察觉这个QOBJECT被释放，会出现错误。</li><li>QT中的智能指针封装为QPointer类，所有QOBJECT的子类都可以用这个智能指针来包装，很多用法与普通指针一样。</li></ul><h2 id="常见类" tabindex="-1">常见类 <a class="header-anchor" href="#常见类" aria-label="Permalink to &quot;常见类&quot;">​</a></h2><p><strong>Qt中最基本的类</strong></p><ul><li>QObject派生类 <ul><li>QWidget</li><li>QLayout</li><li>QThread</li><li>QTcpSocket</li></ul></li><li>非QObject派生类 <ul><li>QString：处理字符串</li><li>QImage：加载与保存图像</li><li>QColor：处理色彩</li><li>……</li></ul></li></ul><hr><p>QObject类是所有能够处理signal，slot和事件的Qt对象的基类</p><ul><li>Qt 对象模型的核心 <ul><li>绝大多数类的基类</li><li>所有的QWidgets都是QObject</li><li>提供对象树和对象的关系</li><li>QObject在整个QT的概念体系中处于一个非常重要的位置</li><li>提供了信号-槽的通信机制</li></ul></li><li>具有三个作用 <ul><li>内存管理</li><li>Introspection(内省)</li><li>事件处理</li></ul></li></ul><hr><ul><li>QApplication类负责GUI应用程序的控制流和主要的设置，它包括主事件循环体，负责处理和调度所有来自窗口系统和其他资源的事件</li><li>处理应用程序的开始，结束以及会话管理</li><li>QApplication是QObject类的子类</li></ul><hr><ul><li>在非图形程序中，QCoreApplication类接管了QApplication类在GUI应用程序中的角色：它使得事件循环机制能够使用。如果你需要异步通讯的话，这将是非常有用的，或者不同的线程之间，或者通过网络套接字。</li><li>QCoreApplication是QObject类的子类</li></ul><hr><ul><li>QWidget类继承了QObject类的属性</li><li>QWidget类是所有用户接口对象的基类 组件是用户界面的单元组成部分，接收鼠标， 键盘和从其它窗口系统来的事件</li><li>QWidget类有很多成员函数，但一般不直接使用，而通过子类继承来使用其函数功能</li></ul><hr><h2 id="qt窗口与对话框" tabindex="-1">Qt窗口与对话框 <a class="header-anchor" href="#qt窗口与对话框" aria-label="Permalink to &quot;Qt窗口与对话框&quot;">​</a></h2><p>Qt提供的默认基类只有QWidget、QMainWindow和QDialog三种</p><ul><li><p><strong>QMainWindow</strong>是带有菜单栏和工具栏的主窗口类</p></li><li><p><strong>QDialog</strong> 是各种对话框的基类，而它们全部继承自 QWidget。不仅如此，</p></li><li><p><strong>QWidget</strong> 类是所有用户界面对象的基类，被称为基础窗口部件。</p></li><li><p>QWidget 继承自 QObject 类和 QPaintDevice 类，其中QObject 类是所有支持 Qt 对象模型（Qt Object Model)的基类，QPaimDevice类是所有可以绘制的对象的基类。 <img src="https://note.youdao.com/yws/res/6464/3FE07C5C91294019B25B3592A799A58F" alt="image"></p></li></ul><h4 id="qwidget" tabindex="-1">QWidget <a class="header-anchor" href="#qwidget" aria-label="Permalink to &quot;QWidget&quot;">​</a></h4><p>基础窗口部件主要用于自定义窗口。<br><code>QWidget(QWidget *parent = 0, Qt::WindowFlags f = 0);</code></p><p>其中参数 parent 指向父窗口，如果这个参数为 0，则窗口就成为一个顶级窗口<br> 参数 f 是构造窗口的标志，主要用于控制窗口的类型和外观等，有以下常用值。<br> 1）<code>Qt::FramelessWindowHint</code>：没有边框的窗口。<br> 2）<code>Qt::WindowStaysOnTopHint</code>：总是最上面的窗口。<br> 3）<code>Qt::CustomizeWindowHint</code>：自定义窗口标题栏，以下标志必须与这个标志一起使用才有效，否则窗口将有默认的标题栏。<br> 4）<code>Qt::WindowTitleHint</code>：显示窗口标题栏。<br> 5）<code>Qt::WindowSystemMenuHint</code>：显示系统菜单。<br> 6）<code>Qt::WindowMinimizeButtonHint</code>：显示最小化按钮。<br> 7）<code>Qt::WindowMaximizeButtonHint</code>：显示最大化按钮。<br> 8）<code>Qt::WindowMinMaxbuttonHint</code>：显示最小化按钮和最大化按钮。<br> 9）<code>Qt::WindowCloseButtonHint</code>：显示关闭按钮。</p><h5 id="独立窗口" tabindex="-1">独立窗口 <a class="header-anchor" href="#独立窗口" aria-label="Permalink to &quot;独立窗口&quot;">​</a></h5><p>窗口构造的时候如果有Qt::Window标志，那么它就是一个独立窗口，否则就是一个依附于其他独立窗口的窗口部件。顶级窗口一定是独立窗口，但独立窗口不一定是顶级的，它可以有父窗口，当父窗口被析构时它也会随之被析构。独立窗口一般有自己的外边框和标题栏，可以有移动、改变大小等操作。</p><h4 id="对话框qdialog" tabindex="-1">对话框QDialog <a class="header-anchor" href="#对话框qdialog" aria-label="Permalink to &quot;对话框QDialog&quot;">​</a></h4><p>独立对话框</p><ul><li>File Open, Save As,…</li><li>Printer Dialog</li><li>Font Selector</li><li>Message Box</li><li>Progress Dialog<br> …</li></ul><p>可定制对话框</p><ul><li>Tab Dialog</li><li>Wizard</li></ul><h5 id="文件对话框-qfiledialog" tabindex="-1">文件对话框（QFileDialog） <a class="header-anchor" href="#文件对话框-qfiledialog" aria-label="Permalink to &quot;文件对话框（QFileDialog）&quot;">​</a></h5><p>获取文件名</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QString MainWindow::getOpenFileName()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    QString filename = QFileDialog::getOpenFileName(</span></span>
<span class="line"><span>                this,</span></span>
<span class="line"><span>                &quot;Open Document&quot;,</span></span>
<span class="line"><span>                QDir::currentPath(),</span></span>
<span class="line"><span>                &quot;Document files(*.doc);;All files(*.*)&quot;);</span></span>
<span class="line"><span>    if(!filename.isNull())</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        //</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return filename;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>保存文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QString MainWindow::getSaveFileName()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    QString filename = QFileDialog::getSaveFileName(</span></span>
<span class="line"><span>                this,</span></span>
<span class="line"><span>                &quot;Save Document&quot;,</span></span>
<span class="line"><span>                QDir::currentPath(),</span></span>
<span class="line"><span>                &quot;Documents(*.doc)&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>获取路径</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QString MainWindow::getExistingDirectory()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    QString dirname = QFileDialog::getExistingDirectory(</span></span>
<span class="line"><span>                this,</span></span>
<span class="line"><span>                &quot;Select a Directory&quot;,</span></span>
<span class="line"><span>                QDir::currentPath());</span></span>
<span class="line"><span>    return dirname;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h5 id="消息对话框-qmessagebox" tabindex="-1">消息对话框（QMessageBox） <a class="header-anchor" href="#消息对话框-qmessagebox" aria-label="Permalink to &quot;消息对话框（QMessageBox）&quot;">​</a></h5><ul><li><p>about()</p></li><li><p>aboutQt()</p></li><li><p>critical()</p></li><li><p>information()</p></li><li><p>question()</p></li><li><p>warning()</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QMessageBox::XXX(</span></span>
<span class="line"><span>      this,</span></span>
<span class="line"><span>      &quot;Application Name&quot;,</span></span>
<span class="line"><span>      &quot;An XXX message.&quot;);</span></span></code></pre></div></li></ul><h5 id="输入对话框-qinputdialog" tabindex="-1">输入对话框（QInputDialog） <a class="header-anchor" href="#输入对话框-qinputdialog" aria-label="Permalink to &quot;输入对话框（QInputDialog）&quot;">​</a></h5><p>文本输入框</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>bool ok;</span></span>
<span class="line"><span>QString text = QInputDialog::getText(</span></span>
<span class="line"><span>            this,</span></span>
<span class="line"><span>            &quot;String&quot;,</span></span>
<span class="line"><span>            &quot;Enter a city name:&quot;,</span></span>
<span class="line"><span>            QLineEdit::Normal,</span></span>
<span class="line"><span>            &quot;Beijing&quot;,</span></span>
<span class="line"><span>            &amp;ok);</span></span>
<span class="line"><span>if(ok &amp;&amp; !text.isEmpty())</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    //   ……</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>return text;</span></span></code></pre></div><p>选项输入框</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>bool ok;</span></span>
<span class="line"><span>    QStringList items;</span></span>
<span class="line"><span>    items &lt;&lt; &quot;One&quot; &lt;&lt; &quot;Two&quot; &lt;&lt; &quot;Three&quot;;</span></span>
<span class="line"><span>    QString item = QInputDialog::getItem(</span></span>
<span class="line"><span>                this,</span></span>
<span class="line"><span>                &quot;Item&quot;,</span></span>
<span class="line"><span>                &quot;Pick an item:&quot;,</span></span>
<span class="line"><span>                items,</span></span>
<span class="line"><span>                0,</span></span>
<span class="line"><span>                false,</span></span>
<span class="line"><span>                &amp;ok);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if(ok &amp;&amp; !item.isEmpty())</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    //   ……</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>return item;</span></span></code></pre></div><p>自旋对话框</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>bool ok;</span></span>
<span class="line"><span>int value = QInputDialog::getInt</span></span>
<span class="line"><span>        (</span></span>
<span class="line"><span>            this,</span></span>
<span class="line"><span>            &quot;Integer&quot;,</span></span>
<span class="line"><span>            &quot;Enter an angle:&quot;,</span></span>
<span class="line"><span>            90,</span></span>
<span class="line"><span>            0,</span></span>
<span class="line"><span>            360,</span></span>
<span class="line"><span>            1,</span></span>
<span class="line"><span>            &amp;ok);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>return value;</span></span></code></pre></div><h5 id="颜色对话框-qcolordialog" tabindex="-1">颜色对话框（QColorDialog） <a class="header-anchor" href="#颜色对话框-qcolordialog" aria-label="Permalink to &quot;颜色对话框（QColorDialog）&quot;">​</a></h5><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QColor MainWindow::getColor()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    QColor color =</span></span>
<span class="line"><span>        QColorDialog::getColor(</span></span>
<span class="line"><span>            Qt::yellow,</span></span>
<span class="line"><span>            this);</span></span>
<span class="line"><span>    if(color.isValid())</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        // ……</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return color;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h5 id="字体对话框-qfontdialog" tabindex="-1">字体对话框（QFontDialog） <a class="header-anchor" href="#字体对话框-qfontdialog" aria-label="Permalink to &quot;字体对话框（QFontDialog）&quot;">​</a></h5><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QFont MainWindow::getFont()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    bool ok;</span></span>
<span class="line"><span>    QFont font =QFontDialog::getFont(</span></span>
<span class="line"><span>        &amp;ok,</span></span>
<span class="line"><span>        QFont(&quot;Arial&quot;,18),</span></span>
<span class="line"><span>        this,</span></span>
<span class="line"><span>        &quot;Pick a font&quot;);</span></span>
<span class="line"><span>    if(ok)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        //...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return font;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="布局管理" tabindex="-1">布局管理 <a class="header-anchor" href="#布局管理" aria-label="Permalink to &quot;布局管理&quot;">​</a></h2><p>布局管理器主要常用的三个类：</p><ul><li><strong>QHBoxLayout</strong></li><li><strong>QVBoxLayout</strong></li><li><strong>QGridLayout</strong></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>setContentsMargins(int left, int top, int right, int bottom)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setSpacing(int)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>addStretch(int stretch = 0)</span></span></code></pre></div><h4 id="qsplitter" tabindex="-1">QSplitter <a class="header-anchor" href="#qsplitter" aria-label="Permalink to &quot;QSplitter&quot;">​</a></h4><p>QSplitter 是一个可以包含一些其他窗口部件的窗口部件。在切分窗口（splitter)中的这些窗口部件会通过分隔条（splitter handle）而分隔开来。用户可以通过拖动这些切分条来改变切分窗口中子窗口部件的大小。</p><h4 id="qscrollarea" tabindex="-1">QScrollArea <a class="header-anchor" href="#qscrollarea" aria-label="Permalink to &quot;QScrollArea&quot;">​</a></h4><p>QScrollArea类提供了一个可以滚动的视口和两个滚动条，使用方法，就是以我们想要添加滚动条的窗口部件为参数调用setWidget()。<br> 默认情况下，只有在视口的大小小于子窗口部件的大小时，才会把滚动条显示出来。但是通过设置滚动条策略，可以强制滚动条总是可见。</p><h4 id="qstatckwidget" tabindex="-1">QStatckWidget <a class="header-anchor" href="#qstatckwidget" aria-label="Permalink to &quot;QStatckWidget&quot;">​</a></h4><ol><li>所有组件垂直于屏幕的方向上被管理</li><li>每次只有一个组件会显示在屏幕上</li><li>只有最顶层的组件会被最终显示</li></ol><p><strong>栈式布局管理器的特点</strong></p><ol><li>组件大小一致且充满父组件的显示区</li><li>不能直接嵌套其它布局管理器（可以依赖中间组件间接嵌套）</li><li>能够自由切换需要显示的组件</li><li>每次能且仅能显示一个组件</li></ol><h2 id="向导对话框" tabindex="-1">向导对话框 <a class="header-anchor" href="#向导对话框" aria-label="Permalink to &quot;向导对话框&quot;">​</a></h2><ol><li>QWizard 用来实现软件的使用介绍指南是非常不错的;</li><li>QWizard是继承自QDialog的，而每一个向导页面是由QWizardPag（QWidget的一个子类）来执行的，采用addPage()来增加创建的QWizardPage。</li><li>QWizardPage可以添加标题，标题会显示在页的最左上方。setTitle()。还可以设置子标题，子标题跟着标题的下面的位置，起到说明的作用。setSubTitle()。</li><li>可以用setPixmap来为向导提供图片，void QWizard::setPixmap ( WizardPixmap which, const QPixmap &amp; pixmap )</li></ol><hr><ul><li>向导有四种风格：ClassicStyle，ModernStyle，MacStyle，AeroStyle。(setWizardStyle设置)</li><li>枚举类WizardPixmap有四个值：</li></ul><ol><li>QWizard::WatermarkPixmap：ClassicStyle，ModernStyle页面的左侧设置图片</li><li>QWizard::LogoPixmap：ClassicStyle，ModernStyle 右侧设置图片</li><li>QWizard::BannerPixmap：ModernStyle设置的背景图片</li><li>QWizard::BackgroundPixmap：MacStyle设置背景图</li></ol><ul><li>在很多向导中，页的内容会被一些默认的值或者用户设置的值影响，QWizard提供一个叫“field”(叫它域吧)的机制。</li><li>它允许在向导页上注册一个域（例如一个QLineEdit），并可以在任何其他页中存取它的值。可以通过QWizardPage：：registerField()调用域。这个域也可以是托管的（mandatory）域（带星号“*”），托管的域必须填充才能进入到下一个页。</li></ul><p>例如： registerField(&quot;className*&quot;, classNameLineEdit);注册好了以后就可以用field(“**”)使用了。</p><p>例如： QString className=field(&quot;className&quot;).toString();域的内容是作为QVariant返回的</p><ul><li><p>向导可以为自己添加按钮等控件用来指导向导页面的翻转移动，以及结束。</p></li><li><p>Next或Finish按钮是否用一个方法是通过用户的输入，另一个方法是重新实现validateCurrentPage()或</p></li><li><p>QWizardPage::validatePage()，通过它去批准是否生效还可以通过它去确认用户的输入是否符合要求</p></li></ul><h2 id="qmainwindows" tabindex="-1">QMainWindows <a class="header-anchor" href="#qmainwindows" aria-label="Permalink to &quot;QMainWindows&quot;">​</a></h2><p>QMainWindow类提供了一个典型应用程序的主窗口框架，应用程序中的主窗口是与用户进行 长时间交互的顶层窗口</p><ul><li><p>QMainWindow内部封装了菜单栏、工具栏、中心组件、停靠组件、状态栏等。</p></li><li><p>QMainWindow常常被继承，因为这使的封装中央部件、菜单和工具以及窗口状态条变得容易，当用户点击菜单项或工具条按钮时，槽会被调用。基于主窗口的应用程序，默认已经有了自己的布局管理器</p></li></ul><h4 id="主窗口菜单" tabindex="-1">主窗口菜单 <a class="header-anchor" href="#主窗口菜单" aria-label="Permalink to &quot;主窗口菜单&quot;">​</a></h4><p>主窗口菜单可以通过UI工具绘制出来，也可以通过QMenuBar和QMenu来定制。 QMenu用于定制菜单的菜单项、下拉菜单及弹出菜单项，等等。可以有图标、文字信息、热键及提示信息。通过QMenu完全可以实现菜单的个性化定制。 横向菜单栏QMenuBar，使用用于管理一组菜单。通过addMenu()向菜单栏添加菜单。</p><h4 id="主窗口工具栏" tabindex="-1">主窗口工具栏 <a class="header-anchor" href="#主窗口工具栏" aria-label="Permalink to &quot;主窗口工具栏&quot;">​</a></h4><p>工具栏是应用程序中集成各种功能使用快捷方式的区域，不是应用程序必须存在的组件，工具栏的元素可以是各种窗口组件，但通常以图标按钮的方式存在。 QT中提供了预定义的工具栏相关组件，工具栏QToolBar和快捷项QAction。</p><ul><li><p>QToolButton类实现了具有一个图标，一个3D框架和一个可选的标签的工具栏</p></li><li><p>QToolButton通常在QToolBar内并排出现。一个程序可含有任意数量的工具栏并且用户可以自由移动它们</p></li><li><p>工具栏可以包括几乎所有部件，例如QComboBox和QSpinBox</p></li></ul><h4 id="主窗口状态栏" tabindex="-1">主窗口状态栏 <a class="header-anchor" href="#主窗口状态栏" aria-label="Permalink to &quot;主窗口状态栏&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QStatusBar     *sb = statusBar();</span></span>
<span class="line"><span>    QLabel*  status1 = new QLabel(&quot;Line: 1  Col: 1&quot;,this);</span></span>
<span class="line"><span>    QLabel*  status2 = new QLabel(&quot;Lines: 0  Length: 0&quot;,this);</span></span>
<span class="line"><span>    status1-&gt;setAlignment(Qt::AlignCenter);                    </span></span>
<span class="line"><span>    status2-&gt;setAlignment(Qt::AlignCenter);</span></span>
<span class="line"><span>    status1-&gt;setMinimumWidth(200);      //设置最小宽度,避免与旁边的信息紧靠在一起</span></span>
<span class="line"><span>    status2-&gt;setMinimumWidth(200);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    sb-&gt;addPermanentWidget(status1);</span></span>
<span class="line"><span>    sb-&gt;addPermanentWidget(status2);</span></span></code></pre></div><h4 id="主窗口动作" tabindex="-1">主窗口动作 <a class="header-anchor" href="#主窗口动作" aria-label="Permalink to &quot;主窗口动作&quot;">​</a></h4><p>下面代码实现了一个“Save”菜单项，一个“Save”工具栏按钮和一个“Save”快捷键，并且均有旁述帮助：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QAction *saveAct=new QAction(&quot;Save&quot;,saveIcon,&quot;&amp;Save&quot;,CTRL+Key_S,this);</span></span>
<span class="line"><span>connect(saveAct,SIGNAL(activated()),this,SLOT(save()));</span></span>
<span class="line"><span>saveAct-&gt;setWhatsThis(&quot;Saves the current file.&quot;);</span></span>
<span class="line"><span>saveAct-&gt;addTo(fileMenu);</span></span>
<span class="line"><span>saveAct-&gt;addTo(toolbar);</span></span></code></pre></div><h4 id="主窗口停靠" tabindex="-1">主窗口停靠 <a class="header-anchor" href="#主窗口停靠" aria-label="Permalink to &quot;主窗口停靠&quot;">​</a></h4><p>停靠窗口（dock window）是指在一些可以停靠的QMainWindow中或是浮动为独立窗口。</p><p>QMainWindow提供了4个停靠窗口区域：分别在中央窗口部件的上部、中部、下部、左侧和右侧。</p><h2 id="mvc框架" tabindex="-1">MVC框架 <a class="header-anchor" href="#mvc框架" aria-label="Permalink to &quot;MVC框架&quot;">​</a></h2><blockquote><p>MVC（Model-View-Controller）框架：起源于smalltalk的一种与用户界面设计相关的设计模式，能有效的分离数据和用户界面。</p></blockquote><p><img src="https://note.youdao.com/yws/res/6497/0092FAD9D17749D8BD21041F5C7C98CA" alt="image"></p><ul><li><strong>Model</strong> 处理数据逻辑和程序运行状态</li><li><strong>View</strong> 负责显示用户界面</li><li><strong>Controller</strong>通常负责处理用户交互的部分，从视图读取数据与用户输入，并向模型发送数据。</li><li>在Qt里面我们并没有Controller的概念，而是Delegate（委托），意义很明显：控制器委托模型来处理数据，模型委托控制器来做数据的交互。</li></ul><hr><p>Model是唯一和数据集打交道的组件，View不接触数据源，其所需要的数据可以从Model中取出，而Delegate正式负责协调Model和View上数据。这种将view和数据源隔离的方式有几点好处：</p><ol><li><p>在处理较大的数据集时每个组件各司其职，不至于降低性能。</p></li><li><p>一个Model可以映射到多个View，这样可以以不同的方式查看数据同一份数据。</p></li><li><p>如果底层数据源的存储改变了，我们只需要处理Model就可以了。</p></li></ol><hr><h3 id="模型model-表示数据" tabindex="-1">模型model（表示数据） <a class="header-anchor" href="#模型model-表示数据" aria-label="Permalink to &quot;模型model（表示数据）&quot;">​</a></h3><ul><li>抽象基类QAbstractItemModel</li><li>列表的抽象基类QAbstractListModel、表格的抽象基类QAbstractTableModel</li><li>QDirModel类是文件与目录的存储模型</li><li>QStandardItemModel类</li><li>QStringListModel类</li></ul><table><thead><tr><th>类型</th><th>功能</th></tr></thead><tbody><tr><td>QStringListModel</td><td>存储一个字符串列表</td></tr><tr><td>QStandardItemModel</td><td>存储任意的分层次的数据</td></tr><tr><td>QDirModel</td><td>封装本地文件系统</td></tr><tr><td>QSqlQueryModel</td><td>封装一个SQL结果集</td></tr><tr><td>QSqlTableModel</td><td>封装一个SQL表</td></tr><tr><td>QSqlRclationalTableModel</td><td>用外键封装一个SQL表</td></tr><tr><td>QSortFilterProxyModel</td><td>排序和/或筛选另一个模型</td></tr></tbody></table><hr><h5 id="mvc框架-自定义model" tabindex="-1">MVC框架-自定义Model <a class="header-anchor" href="#mvc框架-自定义model" aria-label="Permalink to &quot;MVC框架-自定义Model&quot;">​</a></h5><p>在我们真正的完成自定义model之前，先来看看在Qt的model-view架构中的几个关键的概念。一个model中的每个数据元素都有一个model索引。这个索引指明这个数据位于model的位置，比如行、列等。这就是前面我们曾经说到过的QModelIndex。每个数据元素还要有一组属性值，称为角色(roles)。这个属性值并不是数据的内容，而是它的属性，比如说，这个数据是用来展示数据的，还是用于显示列头的？因此，这组属性值实际上是Qt的一个enum定义的，比较常见的有Qt::DisplayRole和Qt::EditRole，另外还有Qt::ToolTipRole, Qt::StatusTipRole, 和Qt::WhatsThisRole等。并且，还有一些属性是用来描述基本的展现属性的，比如Qt::FontRole, Qt::TextAlignmentRole, Qt::TextColorRole, Qt::BackgroundColorRole等</p><h5 id="mvc框架-自定义delegate" tabindex="-1">MVC框架-自定义Delegate <a class="header-anchor" href="#mvc框架-自定义delegate" aria-label="Permalink to &quot;MVC框架-自定义Delegate&quot;">​</a></h5><p>我们知道，在经典的 MVC 模型中，view用于向用户展示 model 的数据。但是，Qt提供的不是 MVC 三层架构，而是一个 model/view 设计。这种设计并没有包含一个完整而独立的组件用于管理用户的交互。一般来说，view仅仅是用作对model数据的展示和对用户输入的处理，而不应该去做其他的工作。在这种结构中，为了获得对用户输入控制的灵活性，这种交互工作交给了delegate，也就是“委托”，去完成。</p><p>简单来说，就像它们的名字一样，view 将用户输入委托给 delegate 处理，而自己不去处理这种输入，对这种控制委托的标准接口被定义在 QAbstractItemDelegate 类中。 elegate 可以用于渲染内容，这是通过 paint() 和 sizeHint() 函数来完成的。但是，对于一些简单的基于组件的delegate，可以通过继承 QItemDelegate 或者 QStyledItemDelegate 来实现。这样就可以避免要完全重写 QAbstractItemDelegate 中所需要的所有函数。对于一些相对比较通用的函数，在这两个类中已经有了一个默认的实现。</p><p>Qt提供的标准组件使用 QItemDelegate 提供编辑功能的支持。这种默认的实现被用在 QListView，QTableView 和 QTreeView 之中。view 实用的delegate可以通过 itemDelegate() 函数获得。setItemDelegate() 函数则可以为一个标准组件设置自定义的 delegate。</p><p>一个自定义的delegate也可以直接提供一个编辑器，而不是使用内置的编辑器工厂(editor item factory)。如果你需要这种功能，那么需要实现一下几个函数： createEditor(): 返回修改数据的组件； setEditorData(): 为editor提供编辑的原始数据； updateEditorGeometry(): 保证editor显示在 item view 的合适位置以及大小； setModelData(): 根据editor 的数据更新model的数据。</p><hr><h3 id="视图view-表示用户界面" tabindex="-1">视图view（表示用户界面） <a class="header-anchor" href="#视图view-表示用户界面" aria-label="Permalink to &quot;视图view（表示用户界面）&quot;">​</a></h3><ul><li>抽象基类 QAbstractItemView</li><li>QListView—QListWidget\\QUndoView</li><li>QTableView—QTableWidget</li><li>QTreeView—QTreeWidget</li><li>QColumnView</li><li>QHeaderView</li></ul><p>实际上：QListWidget、QTableWidget、QTreeWidget已经包含数据，是模型与视图集成的类</p><h3 id="代理delegate" tabindex="-1">代理delegate <a class="header-anchor" href="#代理delegate" aria-label="Permalink to &quot;代理delegate&quot;">​</a></h3><blockquote><p>自定义数据条目item的显示与编辑方式</p></blockquote><ul><li>抽象基类QAbstractItemDelegate</li><li>QItemDelegate/QStyleItemDelegate</li><li>类QItemDelegate 由类QSqlRelationDelegate继承</li></ul><h4 id="_1-qtreeview" tabindex="-1">(1)QTreeView <a class="header-anchor" href="#_1-qtreeview" aria-label="Permalink to &quot;(1)QTreeView&quot;">​</a></h4><table><thead><tr><th><code>Header</code></th><th><code>#include&lt;QTreeView&gt;</code></th></tr></thead><tbody><tr><td><code>qmake</code></td><td><code>QT+=widgets</code></td></tr><tr><td><code>Inherits</code></td><td><code>QAbstractItemView</code></td></tr><tr><td><code>Inherited By</code></td><td><code>QTreeWidget</code></td></tr></tbody></table><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QFileSystemModel *model = new QFileSystemModel;</span></span>
<span class="line"><span>model-&gt;setRootPath(QDir::currentPath());</span></span>
<span class="line"><span>QTreeView *tree = new QTreeView(splitter ):</span></span>
<span class="line"><span>tree-&gt;setModel(model);</span></span></code></pre></div><h4 id="_2-qtableview" tabindex="-1">(2)QTableView <a class="header-anchor" href="#_2-qtableview" aria-label="Permalink to &quot;(2)QTableView&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Widget::Widget (QWidget *parent)</span></span>
<span class="line"><span>    :QTableView(parent)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    QStandardItemModel* model = new QStandardItemModel(this);</span></span>
<span class="line"><span>    model-&gt;setItem(0,0,new QStandardItem(&quot;张三&quot;));</span></span>
<span class="line"><span>    model-&gt;setItem(0,1,new QStandardItem(&quot;3&quot;));</span></span>
<span class="line"><span>    model-&gt;setItem(0,2,new QStandardItem(&quot;男&quot;)) ;</span></span>
<span class="line"><span>    this-&gt;setModel(model) ;</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Widget::Widget (QWidget *parent)</span></span>
<span class="line"><span>    :QTableView(parent)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    QStandardItemModel* model = new QStandardItemModel(this);</span></span>
<span class="line"><span>    //设置列字段名.</span></span>
<span class="line"><span>    model-&gt; setColumnCount(3) ;</span></span>
<span class="line"><span>    model-&gt; setHeaderData (0,Qt::Horizontal,&quot;姓名&quot;);</span></span>
<span class="line"><span>    model-&gt; setHeaderData(1,Qt::Horizontal, &quot;年龄&quot;);</span></span>
<span class="line"><span>    model-&gt; setHeaderData(2 ,Qt::Horizontal, &quot;性别&quot;);</span></span>
<span class="line"><span>    //设置行字段名</span></span>
<span class="line"><span>    model-&gt; setRowCount(3) ;</span></span>
<span class="line"><span>    model-&gt;setHeaderData(0,Qt::Vertical,&quot;记录-&quot;);</span></span>
<span class="line"><span>    model-&gt;setHeaderData(1,Qt::Vertical,&quot;记录二&quot;);</span></span>
<span class="line"><span>    model-&gt;setHeaderData(2,Qt::Vertical,&quot;记录三&quot;);</span></span>
<span class="line"><span>    //设置-条数据</span></span>
<span class="line"><span>    model-&gt;setItem(0,0,new QStandardItem(&quot;张三&quot;));</span></span>
<span class="line"><span>    model-&gt;setItem(0,1, new QStandardItem(&quot;3&quot;));</span></span>
<span class="line"><span>    model-&gt;setItem(0,2,new QStandardItem(&quot;男&quot;));</span></span>
<span class="line"><span>    this-&gt;setModel (model);</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,154),i=[t];function p(o,d,r,c,u,h){return e(),n("div",null,i)}const b=a(l,[["render",p]]);export{Q as __pageData,b as default};
