import{_ as e,c as a,o as t,a4 as r}from"./chunks/framework.BtaI5osv.js";const b=JSON.parse('{"title":"依赖图(dependency graph)","description":"","frontmatter":{},"headers":[],"relativePath":"Web/Webpack/概念/依赖图.md","filePath":"Web/Webpack/概念/依赖图.md"}'),p={name:"Web/Webpack/概念/依赖图.md"},c=r('<h1 id="依赖图-dependency-graph" tabindex="-1">依赖图(dependency graph) <a class="header-anchor" href="#依赖图-dependency-graph" aria-label="Permalink to &quot;依赖图(dependency graph)&quot;">​</a></h1><p>每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 <em>依赖关系</em>。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 <em>依赖</em> 提供给应用程序。</p><p>当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 <a href="./entry.html"><em>入口</em></a> 开始，webpack 会递归的构建一个 <em>依赖关系图</em>，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 <em>bundle</em> —— 通常只有一个 —— 可由浏览器加载。</p><blockquote><p>Tip</p><p>对于 <em>HTTP/1.1</em> 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 <em>HTTP/2</em> 来说，你还可以使用<a href="https://webpack.docschina.org/guides/code-splitting/" target="_blank" rel="noreferrer">代码分割</a>进行进一步优化。</p></blockquote><h2 id="further-reading" tabindex="-1">Further Reading <a class="header-anchor" href="#further-reading" aria-label="Permalink to &quot;Further Reading&quot;">​</a></h2><ul><li><a href="https://github.com/webpack/webpack/tree/master/examples/http2-aggressive-splitting" target="_blank" rel="noreferrer">HTTP2 Aggressive Splitting Example</a></li><li><a href="https://medium.com/webpack/webpack-http-2-7083ec3f3ce6" target="_blank" rel="noreferrer">webpack &amp; HTTP/2</a></li></ul>',6),n=[c];function i(o,d,l,s,h,m){return t(),a("div",null,n)}const g=e(p,[["render",i]]);export{b as __pageData,g as default};
