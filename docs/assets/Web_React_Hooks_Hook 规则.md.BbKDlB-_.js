import{_ as o,c as e,o as a,a4 as t}from"./chunks/framework.BtaI5osv.js";const H=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/React/Hooks/Hook 规则.md","filePath":"Web/React/Hooks/Hook 规则.md"}'),r={name:"Web/React/Hooks/Hook 规则.md"},c=t('<h2 id="hook-规则" tabindex="-1">Hook 规则 <a class="header-anchor" href="#hook-规则" aria-label="Permalink to &quot;Hook 规则&quot;">​</a></h2><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。我们提供了一个 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noreferrer">linter</a> 插件来强制执行这些规则：</p><h3 id="只在最顶层使用-hook" tabindex="-1">只在最顶层使用 Hook <a class="header-anchor" href="#只在最顶层使用-hook" aria-label="Permalink to &quot;只在最顶层使用 Hook&quot;">​</a></h3><p>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。 遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 hook 状态的正确。(如果你对此感到好奇，我们在下面会有更深入的解释。)</p><h3 id="只在-react-函数中调用-hook" tabindex="-1">只在 React 函数中调用 Hook <a class="header-anchor" href="#只在-react-函数中调用-hook" aria-label="Permalink to &quot;只在 React 函数中调用 Hook&quot;">​</a></h3><p>不要在普通的 JavaScript 函数中调用 Hook。你可以：</p><ul><li>✅ 在 React 的函数组件中调用 Hook</li><li>✅ 在自定义 Hook 中调用其他 Hook</li></ul><p>遵循此规则，确保组件的状态逻辑在代码中清晰可见。</p>',8),s=[c];function k(i,n,l,h,_,d){return a(),e("div",null,s)}const u=o(r,[["render",k]]);export{H as __pageData,u as default};
