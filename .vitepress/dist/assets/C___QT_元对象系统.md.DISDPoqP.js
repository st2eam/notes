import{_ as a,c as s,o as t,a4 as e}from"./chunks/framework.BtCE5x9j.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"C++/QT/元对象系统.md","filePath":"C++/QT/元对象系统.md"}'),n={name:"C++/QT/元对象系统.md"},p=e(`<h2 id="元对象系统" tabindex="-1">元对象系统 <a class="header-anchor" href="#元对象系统" aria-label="Permalink to &quot;元对象系统&quot;">​</a></h2><h4 id="对象树" tabindex="-1">对象树 <a class="header-anchor" href="#对象树" aria-label="Permalink to &quot;对象树&quot;">​</a></h4><p>Qt提供了一种机制，能够自动、有效的组织和管理继承自QObject的Qt对象，这种机制就是对象树。</p><p>Qt对象树在用户界面编程上是非常有用的。它能够帮助程序员减轻内存泄露的压力。</p><p>比如说当应用程序创建了一个具有父窗口部件的对象时，该对象将被加入父窗口部件的孩子列表。当应用程序销毁父窗口部件时，其下的孩子列表中的对象将被一一删除。这让我们在编程时，能够将主要精力放在系统的业务上，提高编程效率，同时也保证了系统的稳健性。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QDialog *dlg = new QDialog(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>QPushButton *btn = new QPushButton(dlg);</span></span>
<span class="line"><span>QTread* p = new xx;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>delelte dlg;</span></span></code></pre></div><h4 id="元对象系统-1" tabindex="-1">元对象系统 <a class="header-anchor" href="#元对象系统-1" aria-label="Permalink to &quot;元对象系统&quot;">​</a></h4><p>Qt 的元对象系统（Meta-Object System）提供了对象之间通信的信号与槽机制、运行时类型信息和动态属性系统。</p><p>元对象系统由以下三个基础组成：</p><ul><li>QObject 类是所有使用元对象系统的类的基类。</li><li>在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽。</li><li>MOC（元对象编译器）为每个 QObject 的子类提供必要的代码来实现元对象系统的特性。构建项目时，MOC 工具读取 C++ 源文件，当它发现类的定义里有 Q_OBJECT 宏时，它就会为这个类生成另外一个包含有元对象支持代码的 C++ 源文件，这个生成的源文件连同类的实现文件一起被编译和连接。</li></ul><h4 id="q-object" tabindex="-1">Q_OBJECT <a class="header-anchor" href="#q-object" aria-label="Permalink to &quot;Q_OBJECT&quot;">​</a></h4><p>Q_OBJECT是Qt实现元编译系统的一个关键宏，这个宏展开后，里边包含了很多Qt自动生成的代码，包括了变量定义、函数声明等等。</p><p>示例：</p><ol><li>变量<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span></span></span></code></pre></div></li></ol><ul><li>static const qt_meta_stringdata_completerTst_t qt_meta_stringdata_completerTst：存储函数列表</li><li>static const uint qt_meta_data_completerTst：类文件描述<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span></span></span></code></pre></div></li></ul><ol start="2"><li>Q_OBJECT展开后的函数声明 以下5个函数都是使用Q_OBJECT宏自动生成的<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span></span></span></code></pre></div></li></ol><ul><li><p>void xxx::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)</p></li><li><p>const QMetaObject xxx::staticMetaObject</p></li><li><p>const QMetaObject *xxx::metaObject()</p></li><li><p>void *xxx::qt_metacast(const char *_clname)</p></li><li><p>int xxx::qt_metacall(QMetaObject::Call _c, int _id, void **_a)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>为了更好的理解这5个函数，我们首先需要引入一个Qt元对象，也就是QMetaObject，这个类里边存储了父类的源对象、我们当前类描述、函数描述和\`\`\`qt_static_metacall\`\`\`函数地址。</span></span></code></pre></div></li></ul><p><strong>qt_static_metacall</strong> 根据函数索引进行调用槽函数，这个回调中，信号和槽都是可以被回调的，自动生成代码如下</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>if (_c == QMetaObject::InvokeMetaMethod) {</span></span>
<span class="line"><span>    completerTst *_t = static_cast&lt;completerTst *&gt;(_o);</span></span>
<span class="line"><span>    Q_UNUSED(_t)</span></span>
<span class="line"><span>    switch (_id) {</span></span>
<span class="line"><span>    case 0: _t-&gt;lanuch(); break;</span></span>
<span class="line"><span>    case 1: _t-&gt;test(); break;</span></span>
<span class="line"><span>    default: ;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>一个信号声明，但是却也可以被回调，信号是可以当槽函数一样使用的。</p><p>b、staticMetaObject 构造一个QMetaObject对象，传入当前moc文件的动态信息；</p><p>c、metaObject 返回当前QMetaObject，一般而言，虚函数 metaObject() 仅返回类的 staticMetaObject对象。</p><p>qt_metacast 是否可以进行类型转换，被QObject::inherits直接调用，用于判断是否是继承自某个类。判断时，需要传入父类的字符串名称。</p><p>qt_metacall 调用函数回调，内部还是调用了qt_static_metacall 函数，该函数被异步处理信号时调用，或者Qt规定的有一定格式的槽函数(on_xxx_clicked())触发，异步调用代码如下所示</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>void QMetaCallEvent::placeMetaCall(QObject *object)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    if (slotObj_) {</span></span>
<span class="line"><span>        slotObj_-&gt;call(object, args_);</span></span>
<span class="line"><span>    } else if (callFunction_ &amp;&amp; method_offset_ &lt;= object-&gt;metaObject()-&gt;methodOffset()) {</span></span>
<span class="line"><span>        callFunction_(object, QMetaObject::InvokeMetaMethod, method_relative_, args_);</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        QMetaObject::metacall(object, QMetaObject::InvokeMetaMethod, method_offset_ + method_relative_, args_);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><p>除了信号与槽机制外，元对象还提供如下一些功能：</p></li><li><p>QObject::metaObject() 函数返回类关联的元对象，元对象类 QMetaObject 包含了访问元对象的一些接口函数，例如 QMetaObject::className() 函数可在运行时返回类的名称字符串。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QObject *obj = new QPushButton;</span></span>
<span class="line"><span>obj-&gt;metaObject()-&gt;className (); //返回&quot;QPushButton&quot;</span></span></code></pre></div></li><li><p>QMetaObject::newInstance() 函数创建类的一个新的实例。</p></li><li><p>QObject::inherits(const char *className) 函数判断一个对象实例是否是名称为 className 的类或 QObject 的子类的实例。例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QObject *timer = new QTimer; // QTimer 是 QObject 的子类</span></span>
<span class="line"><span>timer-&gt;inherits (&quot;QTimer&quot;); // 返回 true</span></span>
<span class="line"><span>timer-&gt;inherits (&quot;QObject&quot;);  // 返回 true</span></span>
<span class="line"><span>timer-&gt;inherits (&quot;QAbstractButton&quot;);//返回 false,不是 QAbstractButton 的子类</span></span></code></pre></div></li><li><p>QObject::tr() 和 QObject::trUtf8() 函数可翻译字符串，用于多语言界面设计</p></li><li><p>QObject::setProperty() 和 QObject::property() 函数用于通过属性名称动态设置和获取属性值。</p></li></ul><p>对于 QObject 及其子类，还可以使用 qobject_cast() 函数进行动态投射（dynamic cast）。 例如，假设 QMyWidget 是 QWidget 的子类并且在类定义中声明了 Q_OBJECT 宏。创建实例使用下面的语句： QObject *obj = new QMyWidget;</p><p><strong>成功示例:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QWidget *widget = qobject_cast&lt;QWidget *&gt;(obj);</span></span>
<span class="line"><span>QMyWidget *myWidget = qobject_cast&lt;QMyWidget *&gt;(obj);</span></span></code></pre></div><p><strong>失败示例：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QLabel * label = qobject_cast&lt;QLabel *&gt;(obj);</span></span>
<span class="line"><span>这样投射是失败的，返回指针 label 为 NULL，因为 QMyWidget 不是 QLabel 的子类。</span></span>
<span class="line"><span>使用动态投射，使得程序可以在运行时对不同的对象做不同的处理。</span></span></code></pre></div><h4 id="属性系统" tabindex="-1">属性系统 <a class="header-anchor" href="#属性系统" aria-label="Permalink to &quot;属性系统&quot;">​</a></h4><p>Qt 提供一个 Q_PROPERTY() 宏可以定义属性，它也是基于元对象系统实现的。 在 QObject 的子类中，用宏 Q_PROPERTY() 定义属性，其使用格式如下： <img src="https://note.youdao.com/yws/res/6527/83C26369744A45F391662B7C3E8324DE" alt="image"> Q_PROPERTY 宏定义一个返回值类型为 type，名称为 name 的属性，用 READ、WRITE 关键字定义属性的读取、写入函数，还有其他的一些关键字定义属性的一些操作特性。属性的类型可以是 QVariant 支持的任何类型，也可以用户自定义类型。</p><p>Q_PROPERTY 宏定义属性的一些主要关键字的意义如下：</p><ul><li>READ : required, 指定一个读取属性值的函数，没有 MEMBER 关键字时必须设置 READ。</li><li>WRITE: optional,指定一个设定属性值的函数，只读属性没有 WRITE 设置。</li><li>MEMBER: optional,指定一个成员变量与属性关联，成为可读可写的属性，无需再设置 READ 和 WRITE。</li><li>RESET: optional，用于指定一个设置属性缺省值的函数。</li><li>NOTIFY: optional，用于设置一个信号，当属性值变化时发射此信号。</li><li>DESIGNABLE: optional,表示属性是否在 Qt Designer 里可见，缺省为 true。</li><li>CONSTANT: optional,表示属性值是一个常数，对于一个对象实例，READ 指定的函数返回值是常数，但是每个实例的返回值可以不一样。具有 CONSTANT 关键字的属性不能有 WRITE 和 NOTIFY 关键字。</li><li>FINAL : optional, 表示所定义的属性不能被子类重载。</li></ul><p>QWidget 类定义属性的一些例子如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)</span></span>
<span class="line"><span>Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)</span></span></code></pre></div><p>属性的使用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QPushButton *button = new QPushButton;</span></span>
<span class="line"><span>QObject *object = button；</span></span>
<span class="line"><span>object-&gt;setProperty(&quot;flat&quot;, true);</span></span>
<span class="line"><span>bool isFlat= object-&gt;property (&quot;flat&quot;);</span></span></code></pre></div><h4 id="动态属性" tabindex="-1">动态属性 <a class="header-anchor" href="#动态属性" aria-label="Permalink to &quot;动态属性&quot;">​</a></h4><p>QObject::setProperty() 函数可以在运行时为类定义一个新的属性，称之为动态属性。动态属性是针对类的实例定义的。</p><p>动态属性可以使用 QObject::property() 查询，就如在类定义里用 Q_PROPERTY 宏定义的属性一样。</p><p>例如，在数据表编辑界面上，一些字段是必填字段，就可以在初始化界面时为这些字段的关联显示组件定义一个新的 required 属性，并设置值为“true”，如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>editName-&gt;setProperty(&quot;required&quot;, &quot;true&quot;);</span></span>
<span class="line"><span>editName-&gt;property(&quot;required&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>comboSex-&gt;setProperty(&quot;required&quot;, &quot;true&quot;);</span></span>
<span class="line"><span>checkAgree-&gt;setProperty(&quot;required&quot;, &quot;true&quot;);</span></span></code></pre></div><p>然后，可以应用下面的样式定义将这种必填字段的背景颜色设置为亮绿色。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>*[required=&quot;true&quot;]{background-color:lime}</span></span></code></pre></div><h4 id="类的附加信息" tabindex="-1">类的附加信息 <a class="header-anchor" href="#类的附加信息" aria-label="Permalink to &quot;类的附加信息&quot;">​</a></h4><p>属性系统还有一个宏 Q_CLASSINFO()，可以为类的元对象定义“名称——值”信息，如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class QMyClass:public QObject {</span></span>
<span class="line"><span>    Q_OBJECT</span></span>
<span class="line"><span>    Q_CLASSINFO(&quot;author&quot;, &quot;Wang&quot;)</span></span>
<span class="line"><span>    Q_CLASSINFO (&quot;company&quot;, &quot;UPC&quot;)</span></span>
<span class="line"><span>    Q_CLASSINFO(&quot;version &quot;, &quot;3.0.1&quot;)</span></span>
<span class="line"><span>  public:</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>用 Q_CLASSINFO() 宏定义附加类信息后，可以通过元对象的一些函数获取类的附加信息，如 classlnfo(int) 获取某个附加信息，函数原型定义如下： QMetaClassInfo QMetaObject::classInfo(int index) const</p><p>返回值是 QMetaClassInfo 类型，有 name() 和 value() 两个函数，可获得类附加信息的名称和值。</p>`,51),l=[p];function i(c,o,d,r,u,h){return t(),s("div",null,l)}const _=a(n,[["render",i]]);export{g as __pageData,_ as default};
