import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.BtCE5x9j.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Web/CSS/CSS Flex布局.md","filePath":"Web/CSS/CSS Flex布局.md"}'),l={name:"Web/CSS/CSS Flex布局.md"},n=e(`<h2 id="flexbox-布局" tabindex="-1">Flexbox 布局 <a class="header-anchor" href="#flexbox-布局" aria-label="Permalink to &quot;Flexbox 布局&quot;">​</a></h2><blockquote><p>（也叫Flex布局，弹性盒子布局）模块</p></blockquote><p>Flex 布局的主要思想是使父容器能够调节子元素的宽度/高度（和排列顺序），从而能够最好地填充可用空间（主要是为了适应所有类型的显示设备和屏幕尺寸）。flex布容器能够放大子元素使之尽可能填充可用空间，也可以收缩子元素使之不溢出。</p><h3 id="基础知识和术语" tabindex="-1">基础知识和术语 <a class="header-anchor" href="#基础知识和术语" aria-label="Permalink to &quot;基础知识和术语&quot;">​</a></h3><p>如果 “常规”布局基于 block(块) 和 inline(内联) 流动方向，flex 布局则是基于 “flex-flow(弹性流动)” 方向。</p><p><img src="https://note.youdao.com/yws/public/resource/c99ad8ee8977e056429a6768b07877cb/WEBdbb58316be8753200032fbd5f7d79fdd/WEBRESOURCE99e71354bf2f4ea5e691a08a7136331d?ynotemdtimestamp=1656685689905" alt="00-basic-terminology.png"></p><p>在flex布局中，flex 项（就是子元素）</p><ol><li>要么按照 main axis(主轴)（从 main-start 到 main-end ）排布</li><li>要么按照cross axis(交叉轴) (从 cross-start 到cross-end)排布。</li></ol><ul><li><strong>main axis</strong>: flex 容器的主轴，flex 项沿着主轴排布，注意主轴不一定是水平的，主轴是水平还是垂直取决于 flex-direction 属性（见下文）。</li><li><strong>main-start|main-end</strong>: 分别表示主轴的开始\b位置和结束位置，flex 项在容器中会从 main-start 到 main-end 排布。</li><li><strong>main size</strong>: flex 项占据主轴的宽度或高度。flex 项的 main size 属性是要么是“宽度”，要么是“高度”，这取决于主轴方向。</li><li><strong>cross axis</strong>: 垂直于主轴的轴线称为交叉轴，其方向取决于主轴方向。</li><li><strong>cross-start|cross-end</strong>: 分别表示交叉轴的开始位置和结束位置。flex 项在交叉轴上的排布从 cross-start 开始位置到 cross-end 结束位置。</li><li><strong>cross size</strong>: flex 项占据交叉轴的宽度或高度。flex 项的 cross size 属性是要么是“宽度”，要么是“高度”，这取决于交叉轴方向。</li></ul><h3 id="父元素属性-flex-container" tabindex="-1">父元素属性(flex container) <a class="header-anchor" href="#父元素属性-flex-container" aria-label="Permalink to &quot;父元素属性(flex container)&quot;">​</a></h3><p><img src="https://www.html.cn/newimg88/2018/12/01-container.svg" alt="image"></p><h4 id="display" tabindex="-1">display <a class="header-anchor" href="#display" aria-label="Permalink to &quot;display&quot;">​</a></h4><p>用来定义一个 flex 容器。如果设置为 flex 则容器呈现为块状元素，设置为inline-flex 则容器呈现为行内元素。它为所有直接子元素提供了 flex 上下文。</p><p>CSS 代码:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* or inline-flex */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>请注意，CSS 列对 flex 容器没有影响。当然这是 Flexbox 布局的开始。</p><h4 id="flex-direction" tabindex="-1">flex-direction <a class="header-anchor" href="#flex-direction" aria-label="Permalink to &quot;flex-direction&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/flex-direction.svg" alt="image"></p><p>flex-direction 属性确立了主轴，从而定义了 flex 项在 flex 容器中的排布方向。 Flexbox 是单向布局，有些时候我们也称作一维布局。 可以将 flex 项视为主要沿着水平行或垂直列排布。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex-direction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">row</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">row-reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column-reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="flex-wrap" tabindex="-1">flex-wrap <a class="header-anchor" href="#flex-wrap" aria-label="Permalink to &quot;flex-wrap&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/flex-wrap.svg" alt="image"> 默认情况下，flex 项会尽可能地尝试排在同一行上（行或列），通过设置 flex-wrap 来决定 flex 项是否允需要换行。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex-wrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nowrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">wrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">wrap-reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>nowrap (默认值)</strong>: 所有的 flex 项都会在同一行上排布，也就是我们常说的单行，或不换行。</li><li><strong>wrap</strong>: flex 项将从上到下根据实际情况排布再多行上，也就是我们常说的多行，或会换行。</li><li><strong>wrap-reverse</strong>: flex 项将 从下到上 根据实际情况排布再多行上折行。</li></ul><h4 id="justify-content" tabindex="-1">justify-content <a class="header-anchor" href="#justify-content" aria-label="Permalink to &quot;justify-content&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/justify-content.svg" alt="image"></p><p><code>justify-content</code>属性定义了flex 项沿主轴方向的对齐方式。 当一行中的所有 flex 项都是固定大小，或者是灵活大小但已经达到最大 main size 时，它可以帮助分配主轴上的剩余空间。当 flex 项溢出主轴的时候，它还可以用来控制flex 项的对齐方式。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  justify-content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">space-between</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">space-around</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">space-evenly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><p><strong>flex-start (默认值)</strong> : flex 项从主轴的开始位置（main-start）开始排布。</p></li><li><p><strong>flex-end</strong> : flex 项从主轴的结束位置（main-end）开始排布</p></li><li><p><strong>center</strong>: flex 项沿主轴居中排布。</p></li><li><p><strong>space-betwee</strong>n: flex 项沿主轴均匀排布，即我们常说的沿主轴 两端对齐 ，第一个flex 项在主轴开始位置，最后一个flex 项在主轴结束位置。</p></li><li><p><strong>space-around</strong>: flex 项沿主轴均匀排布。要注意的是 flex 项看起来间隙是不均匀的，因为所有 flex 项两边的空间是相等的。第一项在容器边缘有一个单位的空间，但是在两个 flex 项之间有两个单位的间隙，因为每个 flex 项的两侧都有一个单位的间隙。</p></li><li><p><strong>space-evenly</strong>: 任何两个 flex 项之间的间距（以及到 flex 容器边缘的空间）相等。（注：该属性以前很少看到，原因是以前浏览器不支持，chrome 也是 60 版本之后才支持。延伸一下，align-content: space-evenly 也是这个逻辑，大家可以查看下面的demo。 ）</p></li></ul><h4 id="align-items" tabindex="-1">align-items <a class="header-anchor" href="#align-items" aria-label="Permalink to &quot;align-items&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/align-items.svg" alt="image"></p><p><code>align-items</code> 定义了 flex 项如何沿当前行在交叉轴上排布的默认行为。可以将其视为交叉轴（垂直于主轴）上的对齐方式。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  align-items</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">baseline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stretch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>flex-start</strong>: flex 项按照交叉轴的开始位置（cross-start）对齐。</li><li><strong>flex-end</strong>: flex 项按照交叉轴的结束位置（cross-end）对齐。</li><li><strong>center</strong>: flex 项以交叉轴为中心，居中对齐。</li><li><strong>baseline</strong>: flex 项按照他们的文字基线对齐。</li><li><strong>stretch</strong> (默认值) : 拉伸 flex 项以填充整个容器（这里特别要注意：如果 flex 项有尺寸属性（min-width / max-width / width / min-height / max-height / height），那么首先应用这些尺寸属性。</li></ul><h4 id="align-content" tabindex="-1">align-content <a class="header-anchor" href="#align-content" aria-label="Permalink to &quot;align-content&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/align-content.svg" alt="image"></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  align-content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">space-between</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">space-around</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stretch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><strong>flex-start</strong>：多行在容器的开始位置排布</li><li><strong>flex-end</strong>：多行在容器的结束位置排布</li><li><strong>center</strong>：多行在容器的中间位置排布</li><li><strong>space-between</strong>：多行均匀分布；第一行分布在容器的开始位置，最后一行分布在容器的结束位置</li><li><strong>space-around</strong>: 多行均匀分布，并且每行的间距（包括离容器边缘的\b间距）相同；</li><li><strong>strech</strong> (默认值)：多行拉伸以填充满整个剩余空间</li></ul><h3 id="flex-项属性-flex-items" tabindex="-1">flex 项属性 (flex items) <a class="header-anchor" href="#flex-项属性-flex-items" aria-label="Permalink to &quot;flex 项属性 (flex items)&quot;">​</a></h3><p><img src="https://www.html.cn/newimg88/2018/12/02-items.svg" alt="image"></p><h4 id="order" tabindex="-1">order <a class="header-anchor" href="#order" aria-label="Permalink to &quot;order&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/order.svg" alt="image"></p><p>默认情况下，flex 项按源（HTML结构）顺序排布。但是，order 属性可以控制它们在 flex 容器中的显示顺序。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  order</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;integer&gt;;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 默认值是 0 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="flex-grow" tabindex="-1">flex-grow <a class="header-anchor" href="#flex-grow" aria-label="Permalink to &quot;flex-grow&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/flex-grow.svg" alt="image"></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex-grow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;number&gt;; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* default 0 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>注，举个例子帮助你理解：</p><p>比如我们得 flex 容器中有 6 个 flex 项，每个 flex 项的 flex-grow 初始值都是 1。如果我们将每个 flex 项的 flex-grow 相加起来，总和为 6。因此 flex 容器的总宽度被平均分成了 6 份。每个 flex 项增长到填充容器可用空间的1/6。</p><p>当我们将第 3 个 flex 项的 flex-grow 设置为 2 时，flex 容器现在被分成了 7 等份，因为所有 flex-grow 属性是：1 + 1 + 2 + 1 + 1 + 1。第 3 个 flex 项占了整个容器空间的 2/7，其他的占了 1/7。</p><p>具体可以查看 <a href="https://www.html.cn/archives/7236" target="_blank" rel="noreferrer">【Flex布局教程】更多关于Flexbox布局如何工作的 – 用大彩图和GIF动画解释</a>中的 “属性 #2: Flex Grow（拉伸）”</p></blockquote><h4 id="flex-shrink" tabindex="-1">flex-shrink <a class="header-anchor" href="#flex-shrink" aria-label="Permalink to &quot;flex-shrink&quot;">​</a></h4><p>flex-shrink 定义了 flex 项的收缩的能力。（注：与 flex-grow 拉伸正好相反，flex-shrink 决定 flex 项允许收缩多少比例。）</p><p>CSS 代码:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex-shrink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;number&gt;; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* default 1 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>注：负值对于 flex-shrink 无效。</p><h4 id="flex-basis" tabindex="-1">flex-basis <a class="header-anchor" href="#flex-basis" aria-label="Permalink to &quot;flex-basis&quot;">​</a></h4><p>flex-basis 定义了在分配剩余空间之前 flex 项默认的大小。可以设置为某个长度值（e.g. 20%, 5rem,等）或者关键字。关键字 auto 意味着 flex 项会按照其本来的大小显示（暂时由 main-size 关键字完成，直到弃用）。关键字 content 意味着根据内容来确定大小——这个关键字到目前没有被很好地支持，所以测试起来比较困难，与content的类似的关键字还有max-content, min-content, fit-content。</p><p>CSS 代码:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex-basis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;length&gt; | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* default auto */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果设置为 0 , 则 flex 项内容周围的空隙不会根据 flex-grow 按比例分配，如果设置为 auto，则 flex 项周围额外的空袭会根据 flex-grow 按照比例分配，如下图： <img src="https://www.html.cn/newimg88/2017/12/rel-vs-abs-flex.svg" alt="image"></p><h4 id="flex" tabindex="-1">flex <a class="header-anchor" href="#flex" aria-label="Permalink to &quot;flex&quot;">​</a></h4><p>flex 是 flex-grow、flex-shrink、flex-basis 三个属性的缩写。其中第二个和第三个参数(flex-shrink 和 flex-basis)是可选的。默认值为0 1 auto。</p><p>CSS 代码:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | [ &lt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;flex-grow&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;flex-shrink&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;? || &lt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;flex-basis&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>推荐使用缩写形式而不是单独地设置每一个属性，缩写形式中会更加智能地计算出相关值。</p><h4 id="align-self" tabindex="-1">align-self <a class="header-anchor" href="#align-self" aria-label="Permalink to &quot;align-self&quot;">​</a></h4><p><img src="https://www.html.cn/newimg88/2018/12/align-self.svg" alt="image"></p><p>align-self 属性允许某个单独的 flex 项覆盖默认的对齐方式（或由 align-items 指定的对齐方式）。</p><p>具体的属性值得含义可以参考 align-items的解释。</p><p>CSS 代码:</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  align-self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">center</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">baseline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> | </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stretch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>注：float,clear和vertical-align 对 flex 项没有任何作用。</p>`,70),t=[n];function h(p,k,r,g,o,d){return a(),i("div",null,t)}const f=s(l,[["render",h]]);export{E as __pageData,f as default};
