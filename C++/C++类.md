## 类的声明

```cpp
class 类名
{
    private:
        私有的数据和成员函数;
    public:
        公用的数据和成员函数;
    protected:
        保护的数据和成员函数;
}
```

探讨```public/private```给我们带来了什么好处？

1. 类的内部数据得到保护
2. 类的使用方法更加明确，不易出错
3. 类的实现细节更容易修改
4. 内部数据修改有了统一入口，更容易调试

#### 默认生成的函数

- 默认构造函数
- 默认析构函数
- 拷贝构造函数
- 赋值操作符
- 地址运算符

#### 构造函数（Constructor）

- 类声明
  
  - 类名（类型 形参，类型 形参，...）

- 定义对象
  
  - 类名 对象（实参，实参，...）

- 特殊的成员函数
  
  - 对象创建时自动执行，无需用户调用且不能被调用（其实可以）
  
  - 与类名同名
  
  - 可传入参数，无返回值
  
  - 可重载
  
  - 如果用户不定义，则编译器自动生成一个

#### 构造函数初始化列表

```
    class_name(int v1,const int& v2):var(v1),var2(v2)
```

#### 拷贝构造函数

```
classname (const classname &obj) {
   // 构造函数的主体
}
```

以下两种方式会调用拷贝构造函数:

1. classname A(B);

2. classnaem A=B;
   
   #### 析构函数（Destructor）
- 声明
  
  - ~类名（）

- 特殊的成员函数
  
  - 对象生命周期即将结束时自动被调用，释放资源或是执行清理工作
  - 类名前加一个“~“
  - 没有返回值，也没有函数参数
  - 可以显示调用析构函数（慎用）

- Can destructors be virtual in C++
  
  #### 构造和析构函数链

- 构造函数链
  
  - 构造类实例会沿着继承链调用所有的基类ctor
  - 调用顺序: base first, derive next

- 析构函数链
  
  - dtor与ctor正好相反
  - 调用顺序: derive first, base next

#### this指针

在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

- 指向对象自身首地址
- 引用整个对象```*this```
- 仅能在类内部使用

#### static成员

- 修饰类成员
  - 成员函数
  - 成员变量
- 调用方式
  - 类名::静态成员名
- 特殊性
  - this指针无效
  - 不能访问类成员

#### const成员函数

- 不可修改对象

- 声明
  
  - 数据类型 函数名 （参数列表）const；

- 只要成员函数不修改对象就应声明为const
  
  ```
  char *getData() const;
  ```
  
  函数的功能很简单，仅仅是为了获取成员变量的值，没有任何修改成员变量的企图，所以加了 const 限制，这是一种保险的做法，同时也使得语义更加明显。

#### inheritance→get_basic()

```c++
class Superior :public basic{
    basic* get_basic()
    {
        return this;
    }
};
```

## 友元

- 不受权限控制，访问私有成员
- 三种友元
  - 友元函数
  - 友元类
  - 友元成员函数
- 注意
  - 友员也破环了类的隐藏与封装
  - 友元关系不能被继承
  - 友元关系是单向的，不具有交换性
  - 友元关系不具有传递性
